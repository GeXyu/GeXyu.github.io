<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F05%2F27%2Ftest%2F</url>
    <content type="text"><![CDATA[test Java1public static final String TEST= "test"; test jS1234var test = &#123; name:'', age:18&#125; test SQL1select * user;]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java反射方法中的参数名]]></title>
    <url>%2F2017%2F07%2F05%2Fjava-e5-8f-8d-e5-b0-84-e6-96-b9-e6-b3-95-e4-b8-ad-e7-9a-84-e5-8f-82-e6-95-b0-e5-90-8d%2F</url>
    <content type="text"><![CDATA[花了两天撸了个Spring Mvc框架，核心内容就是反射和反射和反射….（调皮一波。SpringMVC有强大的数据绑定，它可以将提交的数据封装并绑定到方法参数中。如果是一个Javabean对象，只需要参数类型反射出来，然后将表单封装到该类型的对象，运行时注入到方法的参数中。而如果方法参数是单个字段，那就需要根据字段名来获取提交的数据。 通过翻阅Spring框架的源代码，对于反射方法参数名，spring提供了两种方法：如果JDK是1.8的话就使用Java 8新的反射API反射出方法参数名，否则就是用ASM框架读取class文件来获取参数名。具体实现如下：实现类为DefaultParameterNameDiscoverer public class DefaultParameterNameDiscoverer extends PrioritizedParameterNameDiscoverer { private static final boolean standardReflectionAvailable = (JdkVersion.getMajorJavaVersion() &gt;= JdkVersion.JAVA_18); public DefaultParameterNameDiscoverer() { if (standardReflectionAvailable) { addDiscoverer(new StandardReflectionParameterNameDiscoverer()); } addDiscoverer(new LocalVariableTableParameterNameDiscoverer()); } } 可以清清楚楚的看到如果jdk版本大于等于1.8则使用StandardReflectionParameterNameDiscoverer 反射出方法参数名。 public class StandardReflectionParameterNameDiscoverer implements ParameterNameDiscoverer { @Override public String\[\] getParameterNames(Method method) { Parameter\[\] parameters = method.getParameters(); String\[\] parameterNames = new String\[parameters.length\]; for (int i = 0; i &lt; parameters.length; i++) { Parameter param = parameters\[i\]; if (!param.isNamePresent()) { return null; } parameterNames\[i\] = param.getName(); } return parameterNames; } @Override public String\[\] getParameterNames(Constructor&lt;?&gt; ctor) { Parameter\[\] parameters = ctor.getParameters(); String\[\] parameterNames = new String\[parameters.length\]; for (int i = 0; i &lt; parameters.length; i++) { Parameter param = parameters\[i\]; if (!param.isNamePresent()) { return null; } parameterNames\[i\] = param.getName(); } return parameterNames; } } 如果jdk版本低于1.8那么就是用asm框架读取class文件，获取方法参数名。具体的实现类：LocalVariableTableParameterNameDiscoverer 。 我们之所以可以反射出方法参数名，是因为在Java编译后的class文件中有个LocalVariableTable 属性，这个属性保存的就是方法参数和方法内的本地变量。但是jdk并没有提供读取LocalVariableTable 属性的api，这就需要借助第三方api。其中操作class文件的主要第三方类库有 ObjectWeb 的 ASM，Apache 的 Commons BCEL还有 Javassist等，其中ASM知名度比较高，AspectJ, CGLIB使用的都是ASM类库。 那么我们看一看如何使用这些类库反射出方法参数名，首先我们准备一个类，类里面只有个sum方法，我们就反射出sum方法参数的名字 public class SumClass { public int sum(int i, int j){ int sum = i + j; return sum; }} JDK1.8反射方法名如果使用jdk的方式反射出方法参数名，首先你的jdk版本必须是1.8以上，而且还需要在编译的时候（javac）需要添加-parameters参数否则我们是反射不到方法参数名的，我们在cmd命令下使用javac -help命令查看帮助。但是在实际开发中我们都是使用maven管理项目，当然maven也为我们提供了方式，只需修改 pom 文件的 maven-compiler-plugin 插件配置即可，就是加上了 compilerArgs 节点。 org.apache.maven.plugins maven-compiler-plugin 3.0 1.8 1.8 -parameters 然后我们在写一个类，看一下实际效果： public class Jdk8Reflect { public static void main(String[] args) throws NoSuchMethodException, SecurityException { //方法名和参数类型列表 parameterTypes Method method = SumClass.class.getDeclaredMethod(“sum”, int.class, int.class); Parameter\[\] parameters = method.getParameters(); for(Parameter p :parameters){ System.out.println(p.getType().getName() + &quot;--&quot; + p.getName()); } } } 我们只需要给出方法名和方法类型列表，就可以反射出方法参数信息。 BCEL反射方法名BCEL首先要在maven添加依赖，然后获取到反射的Class和方法，然后传递给BCEL，最后会得到局部变量表，这个局部变量表会存放方法参数和局部变量，这里sum方法有一个局部变量就是sum，运行下面方法也会打印出来。当然每个方法都隐藏一个this指针，这个指针也会被打印出来。 public class BcelReflect { public static void main(String\[\] args) throws NoSuchMethodException, SecurityException, ClassNotFoundException { Class&lt;?&gt; clazz = SumClass.class; //获取反射的方法 java.lang.reflect.Method method = clazz.getDeclaredMethod(&quot;sum&quot;, int.class, int.class); //设置反射的类 JavaClass lookupClass = Repository.lookupClass(clazz); //设置方法 Method bcelMethod = lookupClass.getMethod(method); //L获取局部变量表 LocalVariableTable localVariableTables = bcelMethod.getLocalVariableTable(); //所有局部变量 LocalVariable\[\] localVariables = localVariableTables.getLocalVariableTable(); for(LocalVariable l:localVariables){ String signature = l.getSignature(); //打印 属性名 签名 属性类型 System.out.println(l.getName() + &quot; ---&quot; + signature +&quot;---&quot; + Type.getReturnType(signature)); } } } 效果如下： ASM反射方法参数名public class AsmReflect { public static void main(String[] args) throws IOException { Class&lt;?&gt; clazz = SumClass.class; ClassReader classReader = new ClassReader(clazz.getName()); classReader.accept(new ParameterNameDiscoveringVisitor(“sum”, “(II)I”), 0); } private static class ParameterNameDiscoveringVisitor extends ClassVisitor{ private final String methodName; private final String methodDesc; public ParameterNameDiscoveringVisitor(String name, String desc) { super(Opcodes.ASM5); this.methodName = name; this.methodDesc = desc; } @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String\[\] exceptions) { if(name.equals(methodName) &amp;&amp; desc.equals(methodDesc)){ return new LocalVariableTableVisitor(); } return null; } } public static class LocalVariableTableVisitor extends MethodVisitor { public LocalVariableTableVisitor() { super(Opcodes.ASM5); } @Override public void visitLocalVariable(String name, String description, String signature, Label start, Label end, int index) { System.out.println(name + &quot; &quot; + description); } } } 效果如下： 由于asm的包比较小 53 KB，这就意味着封装的很少，自己要写的代码比较多。本文github地址：传送门]]></content>
      <categories>
        <category>Java反射方法中的参数名</category>
      </categories>
      <tags>
        <tag>Java反射方法中的参数名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己手写数据库连接池和SpringData]]></title>
    <url>%2F2017%2F06%2F23%2Fe8-87-aa-e5-b7-b1-e6-89-8b-e5-86-99-e6-95-b0-e6-8d-ae-e5-ba-93-e8-bf-9e-e6-8e-a5-e6-b1-a0-e5-92-8cspringdata%2F</url>
    <content type="text"><![CDATA[GitHub地址：传送门实际开发中最常用到连接池，连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用。连接池的出现可以减少资源的频繁请求和释放。 连接池实现的核心就是：当用户关闭连接时，我们把连接返回到池中，好使其他线程使用，而并非真正的关闭。 从这个角度分析，我们只需要重写连接的close方法，就可以实现一个简单的连接池。可以使用包装设计模式或者是代理模式，重写close方法即可。 但是包装设计模式需要重写所有的类，比较麻烦，所以我使用的是代理模式。（具体代码可以参考cn.xiuyu.pool）使用连接池只需要在classpath下面加入jdbc.properties文件配置属性即可 jdbcDriver=com.mysql.jdbc.DriveruserName=rootpassword=tigerurl=jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;characterEncoding=utf8MAXPOOLSIZE=15InitPOOLSIZE=10 Spring Data是一个用于简化数据库访问，并支持云服务的开源框架。其主要目标是使得对数据的访问变得方便快捷，并支持map-reduce框架和云计算数据服务。当spring data与jpa子项目一起使用时只需要写一个dao接口，继承一个jparepository接口。spring data就会自动帮你生成一个代理dao类,并自动生成sql语句运行并返回结果，当有复杂操作时在方法上面添加@Query注解 就可以自动sql语句。这也是我实现的核心。 仿照spring data实现了自动生成代理类，支持简单的CURD，分页,和一些自定的复杂查询如何使用？写一个UserResponse类，将UserRespons继承Repository,再一个实体类User用于封装数据,然后在测试类使用ResponseFactory.getInstance()获取ResponseFactory的工厂实例，然后再使用工厂方法createResponse创建dao代理对象，然后就可以进行快乐的操作了.(这也是我设计不合理的地方，很狗血，这也是我不想继续写下去的原因) UserResponse类public interface UserResponse extends Repository{ @Delete(“delete from user where id=?”) public void deletebyid(int id); @Query(“from User where id=?”) public User QuerybyID(int id); @Updata(&quot;update user set name=?,password=? where id=?&quot;) public void updatebyID(String name,String password,int id); } 封装的方法使用public class TestOrm { //获取代理的类和封装的实体类 ResponseFactory factory = ResponseFactory.getInstance(); UserResponse createResponse = factory.createResponse(UserResponse.class, User.class); @Test //添加用户 public void add() throws Exception{ for(int i=0;i&lt;100;i++){ User u = new User(i+&quot;&quot;,i+&quot;张三&quot;,&quot;123123&quot;); createResponse.insert(u); } } @Test //更新用户 public void update() throws Exception{ User u = new User(&quot;1&quot;,&quot;1&quot;,&quot;1&quot;); createResponse.update(u); } @Test //删除用户 public void delete() throws Exception{ createResponse.delete(1); } @Test //查询用户 public void query() throws Exception{ User u = createResponse.query(1); System.out.println(u); } @Test //获取总数 public void count() throws SQLException{ System.out.println(createResponse.Querycount()); } @Test //分页 public void page() throws InstantiationException, IllegalAccessException, SQLException{ //从第0叶开始查询 查询3页 PageEntity&lt;User&gt; queryBypage = createResponse.QueryBypage(new PageEntity&lt;User&gt;(0, 3)); List&lt;User&gt; entity = queryBypage.getEntity(); System.out.println(entity.size()); for(User u:entity){ System.out.println(u); } } @Test //通过@Query注解查询 public void querybysql() { User querybyID = createResponse.QuerybyID(2); System.out.println(querybyID); } @Test //通过@Delete注解删除 public void deletebysql(){ createResponse.deletebyid(1); } @Test //通过@Update注解更新 public void updatebysql(){ createResponse.updatebyID(&quot;123&quot;, &quot;123&quot;, 2); } }]]></content>
      <categories>
        <category>自己手写数据库连接池和SpringData</category>
      </categories>
      <tags>
        <tag>自己手写数据库连接池和SpringData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己手写SpringMVC]]></title>
    <url>%2F2017%2F06%2F19%2Fe8-87-aa-e5-b7-b1-e6-89-8b-e5-86-99springmvc%2F</url>
    <content type="text"><![CDATA[github 地址：传送门 （更新了使用手册）前两天写了几个注解和处理器的 demo,然后发现可以写一个小框架。感觉 Springmvc 比较合适，之前也看过部分源码，然后就动手搞了一个。 代码没有抽取，设计也是一塌糊涂(比较菜，不会设计)，代码不优雅。实现了几个核心功能：注解式声明控制类，简单的数据绑定，返回 json，支持使用 model 传递数据，Result 风格的跳转和重定向，文件上传（可通过接受json获取上传状态）。如果有志之士可以 fork 一份 添加功能,修复 bug。这里谢过了！ 原理1，首先初始化的时候扫描指定的包，然后扫描类上的注解，生成一个 map。把注解上的值为 key,Java 类的全定限名为 value。2，扫描方法上面的映射，维护映射 map,把 mapping 注解的值为 key,执行的方法为 value。初始化完成！3，然后根据核心 servlet 去分发请求，然后解析返回字符串，进行跳转或者是重定向。具体的思路就是这样如果有志之士可以 fork 一份 添加功能,修复 bug. 打包好了： Download , 可以引入到项目使用啦～用到的 jar 包：bcel-6.0.jar commons-beanutils.jar json-20170516.jar 日志组件: logback那么怎么使用呢？首先在 action 类添加 @Action 注解,在方法添加 @Mapping 注解. @Action(“/index”)public class Controller { @Mapping(value=”/hello”,RequestType=Type.get) public String sayHello(Model model){ model.setParameter(“root”, “Hello”); return “welcome”; }} 它会跳转到 /WEB-INF/jsp 下的 welcome.jsp(这里我写死的,前缀 /WEB-INF/jsp.后缀.jsp) &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8” pageEncoding=”UTF-8”%&gt;&lt;!DOCTYPE html PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd&quot;&gt; Insert title here${root } 然后在项目的 web.xml 文件添加核心 servlet &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;servlet&gt; &lt;servlet-name&gt;main&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.xiuyu.servlet.MainServlet&lt;/servlet-class&gt; &lt;!\-\- 设置最先启动保证初始化 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;init-param&gt; &lt;!\-\- 自定扫描的包 --&gt; &lt;param-name&gt;package&lt;/param-name&gt; &lt;param-value&gt;cn.xiuyu&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;main&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 然后访问地址： http:localhost:8080/${项目名}/index/hello 其实使用上 springmvc 差不多，就这样。 有什么 bug 可以告诉我阿！ 告诉我阿 ！ 我阿！ 阿！！！重定向和转发//post请求 @Mapping(value=”/post”,RequestType=Type.post) public String post(){ System.out.println(“—进入到了post请求 –”); return “redirect:/index/get”; } //get请求value 不备注默认为get @Mapping(value=”/get”,RequestType=Type.get) public String get(Model model){ //model 只支持传值 取值 model.setParameter(“key”, “value”); System.out.println(“—进入到了get请求 –”); return “welcome”; } 接受单字段 可以传入model对象（仅能传输对象）也可以传入request和response对象​//接受单字段 @Mapping(value=”/one”,RequestType=Type.post) public String one(String name,Model model){ //model 只支持传值 取值 model.setParameter(“key”, name); return “welcome”; } 封装实体//封装实体 @Mapping(value=”/object”,RequestType=Type.post) public String object(User u,Model model){ //model 只支持传值 取值 model.setParameter(“key”, u.getName() + “–” + u.getPassword()); return “welcome”; } 返回json 需要返回json对象并且在方法上添加@Json注解//返回json @Mapping(value=”/json”,RequestType=Type.get) @Json public User json(String name,String password,Model model){ //model 只支持传值 取值 User u = new User(); u.setName(name); u.setPassword(password); System.out.println(u); return u; } 上传文件（目前仅能单文件上传）需要把表单设置为enctype=”multipart/form-data”，然后在action方法添加FileEntity实体接受文件，上传到/WEB-INF/upload//文件夹下(*为算法生成) action方法 //上传文件 @Mapping(value=”/uoload”,RequestType=Type.post) public String uoload(FileEntity entity,Model model){ //model 只支持传值 取值 model.setParameter(“key”, entity.getPath() + “ “ +entity.getNewName()); return “welcome”; } 可以在文件上传过程接收文件上传状态，返回一个json对象(封装文件大小pContentLength和已上传文件pBytesRead)]]></content>
      <categories>
        <category>自己手写SpringMVC</category>
      </categories>
      <tags>
        <tag>自己手写SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列总结]]></title>
    <url>%2F2017%2F06%2F17%2Fjvm-e7-b3-bb-e5-88-97-e6-80-bb-e7-bb-93%2F</url>
    <content type="text"><![CDATA[对象的一生Java是一门面向对象的语言，所以在Java程序运行中无时无刻的都有对象被创建。创建的方式有很多种譬如new，克隆，反序列化等方式。当然对象也有很多种譬如普通的Java对象，数组对象或者是代表类的Class对象。那么在jvm中使用new关键字创建一个普通的Java对象，虚拟机都做了那些事情呢。 当虚拟机遇到new 指令时，首先去检查这个指令的参数是否在常量池中定位到一个类的符号引用。并检查这个引用代表的类是否已经被加载，解析，初始化。（双亲委派模型，一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上加载）如果没有那就必须先执行相应的类加载过程。 类加载过程首先虚拟机会使用应用程序类加载器（Application ClassLoader）去加载，然后把加载的数据转换成二进制字节流，再将二进制字节流转换成方法区运行时的数据结构，最后在Java堆中生成一个java.lang.Class对象。并将这个Class对象指向方法区的数据结构。此时类的加载阶段已经结束。 类加载之后会进行链接：1，链接会对二进制字节流进行验证，2，为变量分配空间。3将符号引用替换为直接引用。链接过程完毕后会执行类的初始化。某种程度上来说就是调用Clinit()方法，该方法首先会为调用父类的Clinit()方法，然后为静态语句或者是静态块赋值，该方法还保证了初始化一个类使用单线程。 完成上面操作后，虚拟机将会为新生对象分配内存，当然这个对象会在Java堆的Eden区分配。分配内存的方式主要有两种： 指针碰撞：分配内存是只是将指针向空闲空间移动分配空间的距离 空闲列表：内部维护一个列表，当分配空间时 在列表中找出足够大的空间记录在列表里。 内存分配内存分配完成之后虚拟机会把分配的空间都初始化为零值（不包括对象头），然后就是对对象进行必要的设置，譬如如何找到类的元数据信息，对象的哈希吗，对象的GC分代年龄，这些信息都会被设置到对象头中。如果根据虚拟机是否支持偏向锁，则在对象头中启用偏向。此时在虚拟机的角度来说，新的对象已经产生了，但是对于Java语言来说，对象并没有产生。因为在Java语言中对象的开始时init()方法（构造函数），这个方法是编译器给生成的，init()主要干了下面几件事 调用另一个()方法（本类的另外一个()方法或父类的()方法） 初始化实例变量 此时，一个Java对象真真正正的被创建在了eden区，我们暂时加他小Z，说一下接下来小Z的生活。 GC过程与同步锁在程序正常运转了一段时间多次GC后，小Z从Eden区搬到了From区。之后小Z躲过了多次GC，幸运的存活了下来。当小Z长到了15岁的时候，小Z从From区搬到了敬老院（Old 区）。 当小Z（此时启用偏向）第一次走到了同步代码块时，此时并没有对象与他竞争这块区域，虚拟机便把这块代码的锁给消除了，设置为把小Z的对象头设置了一个偏向锁标志位。后来，来了少量的对象与小Z竞争这个代码块，虚拟机又将锁升级为轻量级锁。再后来来了很多对象，小Z没有竞争过，于是虚拟机把锁设置为重量级锁，并把小Z所在的线程挂起。 随着系统的升级，小Z的作用越来越少，直到没有指针指向小Z,寿终正寝,最后被小Z被虚拟机回收，当系统快要关闭时，小Z的加载器也会被回收掉。小Z的加载器被回收掉，紧接着小Z也会被回收。 本片系列文章参考主要深入了解Java虚拟机一书，还有网络上的一些博客，这里就不一一列举了。本来我是写在word中，然后搬到了blog中。适合于想研究JVM或想深入学习一下JVM的话，可以参考本系列文章。如果有哪里不对，欢迎指出感激不尽。 文章阅读顺序：JVM系列（一）类的加载机制 JVM系列（二）JVM内存结构​ JVM系列（三）GC算法 GC收集器​ JVM系列（四）JVM配置参数​ JVM系列（五）GC分析 JVM系列（六）Java内存模型和线程安全]]></content>
      <categories>
        <category>JVM系列总结</category>
      </categories>
      <tags>
        <tag>JVM系列总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 连接查询Join理解]]></title>
    <url>%2F2017%2F06%2F07%2Fmysql-e8-bf-9e-e6-8e-a5-e6-9f-a5-e8-af-a2join-e7-90-86-e8-a7-a3-ef-bc-88-e5-b7-a6-e8-bf-9e-e6-8e-a5-ef-bc-8c-e5-8f-b3-e8-bf-9e-e6-8e-a5-ef-bc-8c-e5-86-85-e8-bf-9e-e6-8e-a5-ef-bc-8c-e4-ba-a4-e5-8f-89%2F</url>
    <content type="text"><![CDATA[在开发中连接查询是被经常使用到的，连接查询包括内连接，外连接和交叉连接，连接查询通过连接运算符可以实现一条sql查询多个表，连接查询也是关系型数据库模型最主要的特点。在 像mysql，oracle等关系型数据库的设计中，我们常把一个实体的信息存放到一张表，通过外键，中间表或者是某种属性将多个实体的关系保存起来，。我们查询的时侯可以通过连接查询根据实体的关系查询出存放在多个表中的实体的信息。 sql连接关系： 从多表查询join运算符的家族构成来看，多表查询可以分为 内查询，交叉连接，和外连接。其中外连接包括左连接，右连接，和全连接。但是mysql中没有全连接，可以通过union来实现全连接。全连接就是取两个集合的交集。 数据准备： 我准备了三张表，分别用于演示三种连接查询连接。附上github地址。 外连接外连接分为三种：左外连接，右外连接，全外连接，通常我们省略outer 这个关键字。写成：LEFT/RIGHT/FULL JOIN。 左连接（left join） 我所理解的左连接，就是以左表为基表，匹配右表的数据。如果基表的数据在另一张表没有记录。那么在查询的结果集中列显示为NULL，反之 右表没有匹配到左表的数据，则不会在结果集中显示。 我们有一张学生表，用来存放学生的信息，还有一张投票表，存放学生投票的信息。 我们以左连接查询出学生信息及他们投票的信息。 SELECT v.,s. FROM student s LEFT JOIN voter vON s.stu_id = v.voter_id; 我们学生表有10条记录而投票信息表有13条记录，这里以学生表为基表通过查询出13条数据，这也就是右表没有匹配到左表的数据，则不会在结果集中显示。 右查询右连接和左连接唯一不同的就是左连接以join字句左表的表为基表而右查询以join子句右边的表为基表。其实左右查询实际上就是基表不同，结果以基表为准而已。 SELECT v.,s.FROM student s RIGHT JOIN voter v ON s.stu_id = v.voter_id; 可以看出 以右表（投票信息表）为基表，查询出14条记录而且在没有匹配到学生表的记录时，显示的是NULL值，这也说明了如果基表的数据在另一张表没有记录。那么在查询的结果集中列显示为NULL。 全连接（full join）在mysql中没有full join连接运算符。全连接其实就是取两个表的并集，我们可以使用union来实现全连接。但是在union中两个查询的集合列数和集合类型必须是相同的，所以表结构无法演示。 交叉连接（cross join）交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。 select v.,s. from student s cross join voter v 内连接（inner join）这里我们要使用到第三张表dept表，其实内连接就是使用inner join运算发使表自己连接自己。 如果我们查询出子公司和父公司的名字而部门ID 和上级部门ID在同一张表。这时候我们可以使用自连接，当然也可以使用子查询。 SELECT d1.dept_id, d1.dept_name,( SELECT d2.dept_name FROM dept d2 WHERE d1.dept_parent = d2.dept_id ) “上级部门”FROM dept d1 ; 当然，也可以使用自连接 SELECT d1.dept_id,d1.dept_name,d2.dept_name “上级部门”FROM dept d1 JOIN dept d2 ON d1.dept_parent = d2.dept_id; 在这里，使用子查询和自连接的区别就是：因为国家电力公司是老大，没有上级部门也没有匹配到上级部门。所以自连接会过滤掉这条记录。而子查询不会过滤掉而是把上级部门处理为null。 自连接使用最多的就是上表对权形结构的查询]]></content>
      <categories>
        <category>mysql 连接查询Join理解</category>
      </categories>
      <tags>
        <tag>mysql 连接查询Join理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列（六）Java内存模型和线程安全]]></title>
    <url>%2F2017%2F06%2F01%2Fjvm-e7-b3-bb-e5-88-97-ef-bc-88-e5-85-ad-ef-bc-89java-e5-86-85-e5-ad-98-e6-a8-a1-e5-9e-8b-e5-92-8c-e7-ba-bf-e7-a8-8b-e5-ae-89-e5-85-a8%2F</url>
    <content type="text"><![CDATA[多任务处理在现代计算机操作系统中几乎已是一项必备的功能。因为计算机的的运算能力太强大了，就必须使用一些手段去把处理器的运算能力“压榨”出来，否则就会造成很大的浪费，而让计算机同时处理几项任务则是最容易想到，也是被证明是非常有效的“压榨”手段。由此我们引出了多线程。多线程的实现方式主要有三种：使用内核线程实现，使用用户线程实现和使用用户线程和轻量级进程混合使用。 在JDK1.2之前，Java使用的是号称“绿色线程”的用户线程实现。而在JDK1.2之后，Java线程模型被替换成为基于操作系统原生线程模型来实现。当然不同的操作系统支持的线程模型不同，在windows与Linux中使用的是一对一线程模型实现的，即一条java线程就映射到一条轻量级进程中，因为window和Linux系统提供的线程模型是一对一的。 内核进程与轻量级进程和Java进程的关系图 内核线程（Kernel-Level Thread,KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。而轻量级进程与内核线程之间1:1的关系称为一对一的线程模型，轻量级进程与Java进程之间的关系以为1：1（Linux和Windows）。 Java内存与线程模型 从上图中可以看出： 当我们从主内存复制到线程工作内存时，必须有两个动作:第一，由主内存执行读（read）的操作；第二，由线程工作内存执行加载（load）操作。当我们把现成工作内存的数据复制到主内存时，也会有两个操作：第一，由线程工作内存执行存储（store）操作；第二，由主内存执行写(write)操作。 当虚拟机遇到使用变量（use）的命令时，工作内存会把使用的变量传递给线程执行引擎（线程）。当虚拟机遇到给变量赋值（assign）命令时，线程工作内存会接受从线程执行引擎传递过来给工作内存赋值的变量。 这里有三点需要注意 每一个操作都是原子的，即执行期间不会被中断。 –每一个线程有一个工作内存和主存独立。对于普通变量，一个线程中更新的值，不能马上反应在其他变量中。 如果需要在其他线程中立即可见，需要使用 volatile 关键字 线程安全当多个线程访问一个对象是，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者是在调用方法进行任何其他的协调操作，调用这个对象的行文都可以获得正确的结果，那这个对象就是线程安全的。 实现线程安全有三种方式： 互斥同步：同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。互斥是实现同步的一种手段（临界区，互斥量，信号量）。在Java中最基本的互斥同步手段就是synchronized关键字。 非堵塞同步：如果没有线程竞争共享数据，那么操作就成功。如果有线程竞争，产生了冲突，那么就采取补偿措施（一般是cas操作） 无同步方案：如果一个方法或者是代码不涉及共享数据，天生就是线程安全的，那么就不需要同步操作。譬如：可重入代码，线程本地存储。 CAS操作CAS算法的过程是这样：它包含3个参数CAS(V,E,N)。V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。 E==V？V=N：；return V; 锁优化为了在线程之间更高效地共享数据，解决竞争问题，从而提升效率，在JDK1.6加入了各种锁优化技术。 自旋锁与自适应自旋锁如果有两个线程同时并行执行，可以让后面那个线程“稍微等一下”，但不放弃CPU的执行，为了让线程“等一下”可以让线程执行一个忙循环（自旋）。JDK1.6中-XX:+UseSpinning开启，JDK1.7中，去掉此参数，改为内置实现。 自适应自旋锁就是根据对象获取cpu执行的可能性来对对象加锁。随着程序运行和性能监控的不断完善，虚拟机对锁的预测越准，虚拟机就会变得越来越聪明。 消除锁在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。 public static void main(String args[]) throws InterruptedException { long start = System.currentTimeMillis(); for (int i = 0; i &lt; CIRCLE; i++) { craeteStringBuffer(“JVM”, “Diagnosis”); } long bufferCost = System.currentTimeMillis() - start; System.out.println(“craeteStringBuffer: “ + bufferCost + “ ms”);} public static String craeteStringBuffer(String s1, String s2) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString();} 每个StringBuffer.append()方法中都有一个同步块，锁就是这个sb对象。虚拟机观察变量sb，发现sb不会被全局访问到，不会有线程安全。所以会在编译之后，这段代码会忽略所有的同步操作而直接执行。 锁粗化像上面的代码有两个连续的append方法，如果虚拟机检测到有这样一串零碎的操作都对同一个对象加锁，那么虚拟机将会把加锁范围扩展（粗化）到整个操作序列的外部。 public void demoMethod(){ synchronized(lock){ //do sth. } //做其他不需要的同步的工作，但能很快执行完毕 synchronized(lock){ //do sth. }}//锁粗化后public void demoMethod(){ //整合成一次锁请求 synchronized(lock){ //do sth. //做其他不需要的同步的工作，但能很快执行完毕 }} Mark Word在HotSpot虚拟机的对象头中分为两个部分，第一部分是用于存储对象自身的运行时数据，譬如：哈希码，GC分代年龄，在32位和64位的操作系统中分别为32bit和64bit，官方称之为“Mark Word”。另一部分用户存储指向方法去对象类型的指针。 在32位的HotSpot虚拟机中的Mark Word长度为32bit，其中25位存放对象哈希码，4bit用户存储分代年龄，2bit用于存储锁标志位，1bit固定为0，其他状态（轻量级锁，重量级锁，GC标记，可偏向）等信息可以看下图 轻量级锁 在Java中使用操作系统互斥量来实现的传统锁为“重量锁”，轻量锁是在没有多线程的竞争下减少传统重量锁使用操作系统互斥量产生的性能消耗。但是轻量级锁并不是来取缔重量级锁的。 上锁过程： 1，当代码进入到同步快的时候，如果同步对象没有被锁定（锁标志位位 “01”），虚拟机会在当前栈帧创建一个名为锁记录（Lock Record）的空间，用于存放当前锁对象的Mark Word的拷贝。 2，虚拟机使用cas操作尝试将对象的Mark word指向为Lock Recoed的指针。 3，如果指向成功，将对象Mark Word的锁标志位修改为“00”。此时这个线程就拥有了该对象的锁，该对象处于轻量级锁状态。 4，如果指向失败，虚拟机会检查对象的Mark Word是否指向当前线程的栈帧，如果指向当前栈帧，那就可以直接进入同步代码块执行。否则说明该对象有其他线程抢占了。同时说明有多个线程争用同一个锁，那么轻量级锁将会膨胀为重量级锁，锁标志位为“10”。Mark Word存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 解锁过程 1，锁对象的Mark word如果指向线程的锁记录，那就用cas操作把当前对象的Mark word与Mark word指向的锁记录替换回来。 2，如果替换成功，说明解锁成果，整个同步完成。否则，说明有其他线程尝试过获取该锁，那就要在释放锁定同时，唤醒被挂起的线程。 轻量级锁能提升程序同步性能的依据是： 对于绝大部分的锁，在整个同步周期内都是不存在竞争的；如果没有竞争，轻量级锁使用CAS 操作避免了使用互斥量的开销；但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS 操作，因此在有竞争的case下， 轻量级锁会比传统的重量级锁更慢； 偏向锁偏向锁的目的：消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能； 如果说轻量级锁是在无竞争的情况使用CAS 操作去消除同步使用的互斥量：那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS 操作都不做了； 偏向锁的偏： 它的意思是这个锁会偏向于 第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步； 偏向锁的原理：若当前虚拟机启用了偏向锁，那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为01， 即偏向模式；同时使用CAS 操作把获取到这个锁的线程的ID 记录在对象的 Mark Word之中，如果 CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作； 当有另一个线程去尝试获取这个锁时，偏向模式就结束了：根据锁对象目前是否处于被锁定的状态， 撤销偏向后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行； 偏向锁可以提高带有同步但无竞争的程序性能；如果程序中大多数的锁总是被多个不同的线程访问：那偏向模式是多余的； 偏向锁 轻量级锁状态转换以及对象Mark Word的关系 总结： 当进入同步代码块时，锁对象首先会尝试偏向锁，如果失败则尝试轻量级锁。如果轻量级锁失败，则进入自旋锁。再失败，就尝试重量级锁，使用操作系统的互斥量在操作系统层挂起。]]></content>
      <categories>
        <category>JVM系列（六）Java内存模型和线程安全</category>
      </categories>
      <tags>
        <tag>JVM系列（六）Java内存模型和线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列（五）GC分析]]></title>
    <url>%2F2017%2F05%2F31%2Fjvm-e7-b3-bb-e5-88-97-ef-bc-88-e4-ba-94-ef-bc-89gc-e5-88-86-e6-9e-90%2F</url>
    <content type="text"><![CDATA[Java堆分析大部分的Java程序员，我相信都见过java.lang.OutOfMemoryError这个错误，产生该错误原因大多为jvm空间太小， 程序逻辑不合理。具体可以分为一下几类： 对象太大，java堆太小和没有及时回收垃圾导致Java堆的OutOfMemoryError 字节码生成技术生成太多的字节码永久去太小和没有允许Class回收导致永久区的OutOfMemoryError 线程请求的栈深度大于虚拟机允许的深度或者是虚拟机栈动态扩展时，无法申请到足够的空间都会引起Java栈的OutOfMemoryError 当ByteBuffer.allocateDirect()无法从操作系统获得足够的空间，会导致直接内存的OutOfMemoryError 综合上面四点，发生OutOfMemoryError的地方为一下几个区域：Java堆，永久区（方法区），Java栈，直接空间。既然我们知道了发生错误的几个地方，那么就看一下什么样的程序能够产生错误又有什么方法可以解决。 Java堆public static void main(String args[]){ System.out.println(Runtime.getRuntime().maxMemory()/1024/1024); System.out.println(Runtime.getRuntime().totalMemory()/1024/1024); ArrayList list=new ArrayList(); for(int i=0;i&lt;1024;i++){ list.add(new byte[1024*1024]); } } GC日志： 88159Exception in thread “main” java.lang.OutOfMemoryError: Java heap space at cn.xiuyu.jvm.oom.Demo1.main(Demo1.java:15) 从程序上看 我们需要分配1024个1M的数据，但是我这里虚拟机默认的配置堆的最大为881M，并不能分配1024个空间，所以导致Java堆的OutOfMemoryError。 解决方案：增大Java堆空间，及时释放内存。 永久区//工厂类public class ObjectFactory implements MethodInterceptor{ private Object target; public ObjectFactory(Object target){ this.target = target; } public Object getObject(){ Enhancer en = new Enhancer(); en.setSuperclass(target.getClass()); en.setCallback(this); return en.create(); } @Override public Object intercept(Object proxy, Method method, Object\[\] args, MethodProxy arg3) throws Throwable { return method.invoke(proxy, args); } }//测试类public static void main(String[] args) { ObjectFactory factory = new ObjectFactory(new Demo2()); for(int i=0; i&lt;1000000000;i++){ factory.getObject(); } } GC日志： [GC [PSYoungGen: 0K-&gt;0K(51072K)] 102K-&gt;102K(728320K), 0.0000858 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][Full GC [PSYoungGen: 0K-&gt;0K(51072K)] [PSOldGen: 102K-&gt;102K(677248K)] 102K-&gt;102K(728320K) [PSPermGen: 2047K-&gt;2047K(2048K)], 0.0031717 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][GC [PSYoungGen: 0K-&gt;0K(52416K)] 102K-&gt;102K(729664K), 0.0002032 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][Full GC [PSYoungGen: 0K-&gt;0K(52416K)] [PSOldGen: 102K-&gt;102K(677248K)] 102K-&gt;102K(729664K) [PSPermGen: 2047K-&gt;2047K(2048K)], 0.0039734 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Error occurred during initialization of VMjava.lang.OutOfMemoryError: PermGen space at java.lang.StringCoding.encode(StringCoding.java:266) at java.lang.String.getBytes(String.java:947) at java.lang.ClassLoader$NativeLibrary.load(Native Method) at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1778) at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1695) at java.lang.Runtime.loadLibrary0(Runtime.java:823) at java.lang.System.loadLibrary(System.java:1030) at java.lang.System.initializeSystemClass(System.java:1077) 当我们使用CGLIB，ASM之类的字节码生成类库时，会产生大量的字节码。这些字节码加载到永久区，如果永久区太小，会撑爆永久区，最终导致永久区的OutOfMemoryError。 解决方法：增大Perm区 允许Class回收 java**栈**栈溢出指，在创建线程的时候，需要为线程分配栈空间，这个栈空间是向操作系统请求的，如果操作系统无法给出足够的空间，就会抛出OutOfMemoryError。 //-Xmx1g -Xss1mpublic class Demo3 implements Runnable{ @Override public void run() { try { Thread.sleep(10000000); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) { for(int i=0;i&lt;100000;i++){ new Thread(new Demo3(),”Thread”+i).start(); System.out.println(“Thread”+i+” created”); } }} GC日志： Exception in thread “main” java.lang.OutOfMemoryError:unable to create new native thread 由于我们给堆分配了太大的空间，当我们创建一直创建新的线程，导致虚拟机需要向操作系统请求空间，当操作系统无法分配足够的空间时，就抛出了OutOfMemoryError。 解决方法：减少堆内存，减少线程栈大小，增大栈空间 直接内存ByteBuffer.allocateDirect()无法从操作系统获得足够的空间 //-Xmx1g -XX:+PrintGCDetailsfor(int i=0;i&lt;1024000;i++){ ByteBuffer.allocateDirect(1024*1024); System.out.println(i); System.gc(); } GC日志： 从GC日志可以看到 堆空间的使用很少，没有触发GC，而直接内存需要GC回收，但是直接内存无法引起GC。直接内存使用满时，无法触发GC。如果堆空间很富余，无法触发GC，直接内存可能就会溢出。如果堆空间触发GC，直接内存可以回收。 解决方案：减少堆内存，有意触发GC GC**性能监控工具**]]></content>
      <categories>
        <category>JVM系列（五）GC分析</category>
      </categories>
      <tags>
        <tag>JVM系列（五）GC分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列（四）JVM配置参数]]></title>
    <url>%2F2017%2F05%2F31%2Fjvm-e7-b3-bb-e5-88-97-ef-bc-88-e5-9b-9b-ef-bc-89jvm-e9-85-8d-e7-bd-ae-e5-8f-82-e6-95-b0%2F</url>
    <content type="text"><![CDATA[不管是Minor GC还是Full GC，在GC过程中会导致程序在运行中中断，正确的选择不同的GC策略，调整JVM、GC的参数，可以极大的减少由于GC工作，而导致的程序运行中断方面的问题，进而适当的提高Java程序的工作效率。 新生代GC（Minor GC）：发生在新生代的垃圾收集动作，因为Java对象大多具备朝生夕灭的特点，所以Minor GC非常频繁，回收速度也很快。 老年代GC（Major GC/Full GC）：指发生在老年代的GC动作，出现了Full GC，一般会伴随至少一次Minor GC（但非绝对）。 GC日志 阅读GC日志是理解Java虚拟机内存问题的基础技能，它只是一些人为的规则。在程序运行中可以通过配置-XX:+PrintGCDetails来打印日志输出。 然后再控制台会打印出GC 信息 首先 GC日志的开头 “GC”或者是“Full GC”说明这次垃圾收集的停顿类型，而不是区分为新生代还是老年代的垃圾收集动作，如果有Full GC说明这次GC过程中发生了Stop The World，从图上看显然这次GC中没有发生Stop The World。接下来PSYoungGen 表示使用的垃圾收集器为Parallel Scavenge收集器。 后面方括号5520K-&gt;1280K(8192K)表示“GC前该区域已使用的容量 -&gt; GC后该内存区域已使用容量（改内存的总容量）”，而方括号外面的5520K-&gt;1280K(18432K) 表示”GC前Java堆已使用的容量-&gt;GC后Java堆已使用的容量” 再往后 0.0027784 secs 表示该内存区域GC所占用的时间，单位是时间。而[Times: user=0.00 sys=0.00, real=0.00 secs] 这里面对user,sys,real 与Linuxd time命令所输出的时间含义一样，分别表示用户态消耗的CPU时间，内核态消耗的CPU事件和操作开始到结束所经过的撞钟时间（Wall Clock Time）。 Heap以后就是GC堆的详细信息 在PSYoungGen可以看到新生代的Eden，Form， To区域。这里“ PSYoungGen total 8192K used 6588K”其中total表示新生代使用的区域总和=Eden + 一个Survivor区， used 6588K表示使用了6588K。“ [0x000000000b090000, 0x000000000ba90000, 0x000000000ba90000)”分别表示地址的低边界，当前边界，最高边界。可以通过（最高边界-最低边界）/1024/1024得到区域大小，以M为单位。 PSOldGen表示老年代后面的参数代表和PSYoungGen 的相同。PSPermGen表示方法区，参数和上面两者相同，但是该区域一般不发生GC 但是不代表不发生GC。 Java代码和jvm命令（前面几个参数后面会说到） //-Xmx20M -Xms20M -Xmn7M -XX:+PrintGCDetailspublic class Demo4 { public static void main(String[] args) { byte[] b=null; for(int i=0;i&lt;10;i++){ b=new byte[1*1024*1024]; } }} 其他的日志打印命令 -XX:+printGC（打印GC的简要信息） -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式，需要与打印GC信息配合使用） -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800 需要与打印GC信息配合使用） -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 -Xloggc:E:/logs/gc.log 指定位置输出 （E:/logs的gc.log文件） -XX:+TraceClassLoading 打印类加载的信息 -XX:+PrintClassHistogram 按下Ctrl+Break后，打印类的信息（分别显示：序号、实例数量、总大小、类型） 堆分配命令 -Xmx –Xms 指定最大堆 最小堆//-Xmx20m -Xms20m -XX:+PrintGCDetailspublic class Demo1 { public static void main(String[] args) { //运行时的最大内存（byte为单位） System.out.println(Runtime.getRuntime().maxMemory() /1024.0 /1024 + “M”); System.out.println(Runtime.getRuntime().freeMemory() /1024.0/1024 + “M”); System.out.println(Runtime.getRuntime().totalMemory() /1024.0 /1024 + “M”); byte\[\] b=new byte\[1\*1024\*1024\]; System.out.println(&quot;---分配了1M空间给数组----&quot;); System.out.println(Runtime.getRuntime().maxMemory() /1024.0 /1024 + &quot;M&quot;); System.out.println(Runtime.getRuntime().freeMemory() /1024.0/1024 + &quot;M&quot;); System.out.println(Runtime.getRuntime().totalMemory() /1024.0 /1024 + &quot;M&quot;); byte\[\] b4 =new byte\[4\*1024\*1024\]; System.out.println(&quot;----分配了4M空间给数组---&quot;); System.out.println(Runtime.getRuntime().maxMemory() /1024.0 /1024 + &quot;M&quot;); System.out.println(Runtime.getRuntime().freeMemory() /1024.0/1024 + &quot;M&quot;); System.out.println(Runtime.getRuntime().totalMemory() /1024.0 /1024 + &quot;M&quot;); System.gc(); System.out.println(&quot;------GC后-----&quot;); System.out.println(Runtime.getRuntime().maxMemory() /1024.0 /1024 + &quot;M&quot;); System.out.println(Runtime.getRuntime().freeMemory() /1024.0/1024 + &quot;M&quot;); System.out.println(Runtime.getRuntime().totalMemory() /1024.0 /1024 + &quot;M&quot;); } } 运行的结果 17.8125M5.6421966552734375M5.9375M—分配了1M空间给数组—-17.8125M4.642173767089844M5.9375M—-分配了4M空间给数组—17.8125M4.70465087890625M10.0M——GC后—–17.8125M4.741142272949219M10.0M 我们结合代码看一下，首先我们设置了Java堆最大为20M 和 最小堆（初始值）为5M，我们通过runtime接口得到运行时的数据分别是最大空间，空闲空间和总空间。我们第一次打印分别是17M 5M和5.9M。 当我们给分配1M空间时，我们的总空间可以容纳1M空间，所以第二次打印17M，4M，5.9M，可以看出空闲空间变小了因为分配了1M空间，所以说Java分配空间时Java会尽可能维持在最小堆。 当我们再分配4M空间时，我们的空闲空间分配不了4M空间，总空间会扩容。所以分配4M空间后Java堆的情况分别是：17M，4M，10M。 当我们GC一次后，可以看到空闲空间变大了 Xmn指定新生代大小这次我们把Java堆的最大设置为20M，初始值也为20M 把新生代大小设置为1M，执行下面代码看一下GC日志。 //-Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetailspublic static void main(String[] args) { byte[] b=null; for(int i=0;i&lt;10;i++){ b=new byte[1*1024*1024]; } } 打印日志 Heap PSYoungGen total 896K, used 305K [0x000000000b920000, 0x000000000ba20000, 0x000000000ba20000) eden space 768K, 39% used [0x000000000b920000,0x000000000b96c560,0x000000000b9e0000) from space 128K, 0% used [0x000000000ba00000,0x000000000ba00000,0x000000000ba20000) to space 128K, 0% used [0x000000000b9e0000,0x000000000b9e0000,0x000000000ba00000) PSOldGen total 19456K, used 10240K [0x000000000a620000, 0x000000000b920000, 0x000000000b920000) object space 19456K, 52% used [0x000000000a620000,0x000000000b0200f0,0x000000000b920000) PSPermGen total 21248K, used 2972K [0x0000000005220000, 0x00000000066e0000, 0x000000000a620000) object space 21248K, 13% used [0x0000000005220000,0x00000000055072e0,0x00000000066e0000) 可以从GC日志中看到因为新生代太小不能够分配1M空间： 1，没有发生GC 2，对象直接分配到老年代 如果我们把-Xmn（新生代大小）设置的大一些,执行下面的代码（同样的代码） //-Xmx20M -Xms20M -Xmn15m -XX:+PrintGCDetailspublic static void main(String[] args) { byte[] b=null; for(int i=0;i&lt;10;i++){ b=new byte[1*1024*1024]; } } GC日志： Heap PSYoungGen total 13440K, used 10931K [0x000000000ad20000, 0x000000000bc20000, 0x000000000bc20000) eden space 11520K, 94% used [0x000000000ad20000,0x000000000b7ccf38,0x000000000b860000) from space 1920K, 0% used [0x000000000ba40000,0x000000000ba40000,0x000000000bc20000) to space 1920K, 0% used [0x000000000b860000,0x000000000b860000,0x000000000ba40000) PSOldGen total 5120K, used 0K [0x000000000a620000, 0x000000000ab20000, 0x000000000ad20000) object space 5120K, 0% used [0x000000000a620000,0x000000000a620000,0x000000000ab20000) PSPermGen total 21248K, used 2972K [0x0000000005220000, 0x00000000066e0000, 0x000000000a620000) object space 21248K, 13% used [0x0000000005220000,0x00000000055072e0,0x00000000066e0000) 新生代可空间比较大可以容纳10M的数组所以没有发生GC，全部分配在eden而且老年代没有使用。 如果我们把新生代大小设置为7M执行上面的代码 -Xmx20M -Xms20M -Xmn7M -XX:+PrintGCDetails GC日志： [GC [PSYoungGen: 4418K-&gt;256K(6272K)] 4418K-&gt;1280K(19584K), 0.0079350 secs] [Times: user=0.00 sys=0.00, real=0.01 secs][GC [PSYoungGen: 5433K-&gt;288K(6272K)] 6457K-&gt;2336K(19584K), 0.0026655 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Heap PSYoungGen total 6272K, used 1419K [0x000000000b380000, 0x000000000ba80000, 0x000000000ba80000) eden space 5376K, 21% used [0x000000000b380000,0x000000000b49aed0,0x000000000b8c0000) from space 896K, 32% used [0x000000000b9a0000,0x000000000b9e8000,0x000000000ba80000) to space 896K, 0% used [0x000000000b8c0000,0x000000000b8c0000,0x000000000b9a0000) PSOldGen total 13312K, used 2048K [0x000000000a680000, 0x000000000b380000, 0x000000000b380000) object space 13312K, 15% used [0x000000000a680000,0x000000000a880030,0x000000000b380000) PSPermGen total 21248K, used 2981K [0x0000000005280000, 0x0000000006740000, 0x000000000a680000) object space 21248K, 14% used [0x0000000005280000,0x00000000055697e8,0x0000000006740000) 可以看出发生了2次新生代GC，因为Survivor区太小，所以部分对象需要老年代担保，所以老年代使用了15%。 -XX:SurvivorRatio-XX:SurvivorRatio命令是设置两个Survivor区和eden的比，譬如：-XX:SurvivorRatio8表示 两个Survivor :eden=2:8，即一个Survivor占年轻代的1/10。 我们在原来的jvm命令基础再添加-XX:SurvivorRatio=2 参数，表示Survivor与Eden比例为2：2即两个区域一样大。 -Xmx20M -Xms20M -Xmn7M -XX:+PrintGCDetails -XX:SurvivorRatio=2 GC日志 [GC [PSYoungGen: 3423K-&gt;1280K(5376K)] 3423K-&gt;1280K(18688K), 0.0069522 secs] [Times: user=0.00 sys=0.00, real=0.01 secs][GC [PSYoungGen: 4390K-&gt;1280K(5376K)] 4390K-&gt;1280K(18688K), 0.0018699 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][GC [PSYoungGen: 4377K-&gt;1312K(5376K)] 4377K-&gt;1312K(18688K), 0.0007972 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Heap PSYoungGen total 5376K, used 2407K [0x000000000b270000, 0x000000000b970000, 0x000000000b970000) eden space 3584K, 30% used [0x000000000b270000,0x000000000b381f78,0x000000000b5f0000) from space 1792K, 73% used [0x000000000b5f0000,0x000000000b738018,0x000000000b7b0000) to space 1792K, 0% used [0x000000000b7b0000,0x000000000b7b0000,0x000000000b970000) PSOldGen total 13312K, used 0K [0x000000000a570000, 0x000000000b270000, 0x000000000b270000) object space 13312K, 0% used [0x000000000a570000,0x000000000a570000,0x000000000b270000) PSPermGen total 21248K, used 2981K [0x0000000005170000, 0x0000000006630000, 0x000000000a570000) object space 21248K, 14% used [0x0000000005170000,0x00000000054597e8,0x0000000006630000) 可以从GC日志中看到进行了3次新生代的GC ，from区和to区增大，from+to = eden -XX:NewRatio=1-XX:NewRatio命令是设置新生代（eden+2*s）和老年代（不包含永久区）的比值，譬如-XX:NewRatio=4 表示 新生代:老年代=1:4，即年轻代占堆的1/5 我们再次添加一个参数 -XX:NewRatio=1表示新生代与老年代的比例为1：1 -Xmx20M -Xms20M -XX:NewRatio=1 -XX:SurvivorRatio=2 -XX:+PrintGCDetails GC日志： [GC [PSYoungGen: 4419K-&gt;1280K(7680K)] 4419K-&gt;1280K(17920K), 0.0008120 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][GC [PSYoungGen: 5430K-&gt;1280K(7680K)] 5430K-&gt;1280K(17920K), 0.0011638 secs] [Times: user=0.00 sys=0.02, real=0.00 secs]Heap PSYoungGen total 7680K, used 3466K [0x000000000af40000, 0x000000000b940000, 0x000000000b940000) eden space 5120K, 42% used [0x000000000af40000,0x000000000b162ab0,0x000000000b440000) from space 2560K, 50% used [0x000000000b6c0000,0x000000000b800018,0x000000000b940000) to space 2560K, 0% used [0x000000000b440000,0x000000000b440000,0x000000000b6c0000) PSOldGen total 10240K, used 0K [0x000000000a540000, 0x000000000af40000, 0x000000000af40000) object space 10240K, 0% used [0x000000000a540000,0x000000000a540000,0x000000000af40000) PSPermGen total 21248K, used 2981K [0x0000000005140000, 0x0000000006600000, 0x000000000a540000) object space 21248K, 14% used [0x0000000005140000,0x00000000054297e8,0x0000000006600000) 进行了两次新生代的GC。比例分配，新生代 老年代对半开，对象全部留在新生代。 如果我们在此基础上减少Survivor区的大小，即把-XX:SurvivorRatio的值增大 -Xmx20M -Xms20M -XX:NewRatio=1 -XX:SurvivorRatio=3 -XX:+PrintGCDetails GC日志： [GC [PSYoungGen: 5520K-&gt;1280K(8192K)] 5520K-&gt;1280K(18432K), 0.0008124 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Heap PSYoungGen total 8192K, used 6588K [0x000000000afc0000, 0x000000000b9c0000, 0x000000000b9c0000) eden space 6144K, 86% used [0x000000000afc0000,0x000000000b4ef2c8,0x000000000b5c0000) from space 2048K, 62% used [0x000000000b5c0000,0x000000000b700048,0x000000000b7c0000) to space 2048K, 0% used [0x000000000b7c0000,0x000000000b7c0000,0x000000000b9c0000) PSOldGen total 10240K, used 0K [0x000000000a5c0000, 0x000000000afc0000, 0x000000000afc0000) object space 10240K, 0% used [0x000000000a5c0000,0x000000000a5c0000,0x000000000afc0000) PSPermGen total 21248K, used 2981K [0x00000000051c0000, 0x0000000006680000, 0x000000000a5c0000) object space 21248K, 14% used [0x00000000051c0000,0x00000000054a97e8,0x0000000006680000) 进行了1次GC，老年代未使用，新空间使用率更高 -XX:+HeapDumpOnOutOfMemoryError-XX:+HeapDumpOnOutOfMemoryError发生OOM时导出堆到文件，可以与-XX:+HeapDumpPath（导出路径）配合使用。 我们可以设置下面jvm的命令，并执行下面的代码 //-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dumppublic static void main(String[] args) { List list = new ArrayList(); for(int i=0;i&lt;25; i++){ list.add(new byte[1*1024*1024]); } } 控制台输出 java.lang.OutOfMemoryError: Java heap spaceDumping heap to E:/a.dump …Heap dump file created [19910369 bytes in 0.030 secs]Exception in thread “main” java.lang.OutOfMemoryError: Java heap space at cn.xiuyu.jvm.head.Demo8.main(Demo8.java:14) 可以用Java自带的工具VisualVM来看一下jump文件 当然，你也可以再添加一个参数-XX:OnOutOfMemoryError=D:/rintstack.bat %p，当发生OOM的时候执行一个脚本，重启程序或者是发送邮件都是可以的。 堆总结根据实际事情调整新生代和幸存代的大小，官方推荐新生代占堆的3/8，幸存代占新生代的1/10，在OOM时，记得Dump出堆，确保可以排查现场问题。 永久区分配参数 -XX:PermSize 表示永久区初始内存分配大小 -XX:MaxPermSize 表示对永久区分配的内存的最大上限。 在使用CGLIB等一些类库的时候（CGLIB就是“字节码生成”，javac可以说是这些类库的老祖宗。），会产生大量的字节码，这些字节码可能会撑爆永久区造成OutOfMemoryError 可以设置XX:PermSize和-XX:MaxPermSize参数试永久区撑爆，同时还能看到永久区的GC。 首先需要写一个产生对象的工厂对象 public class ObjectFactory implements MethodInterceptor{ private Object target; public ObjectFactory(Object target){ this.target = target; } public Object getObject(){ Enhancer en = new Enhancer(); en.setSuperclass(target.getClass()); en.setCallback(this); return en.create(); } @Override public Object intercept(Object proxy, Method method, Object\[\] args, MethodProxy arg3) throws Throwable { return method.invoke(proxy, args); } } 然后写一个main方法，运行Main前，设置JVM参数 //-XX:+PrintGCDetails -XX:PermSize=1M -XX:MaxPermSize=1Mpublic class Demo9 { public static void main(String[] args) { ObjectFactory factory = new ObjectFactory(new Demo9()); for(int i=0; i&lt;1000000000;i++){ factory.getObject(); } } } GC日志： [GC [PSYoungGen: 0K-&gt;0K(39296K)] 103K-&gt;103K(716544K), 0.0002266 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][Full GC [PSYoungGen: 0K-&gt;0K(39296K)] [PSOldGen: 103K-&gt;103K(677248K)] 103K-&gt;103K(716544K) [PSPermGen: 2046K-&gt;2046K(2048K)], 0.0025604 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][GC [PSYoungGen: 0K-&gt;0K(39296K)] 103K-&gt;103K(716544K), 0.0000936 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][Full GC [PSYoungGen: 0K-&gt;0K(39296K)] [PSOldGen: 103K-&gt;103K(677248K)] 103K-&gt;103K(716544K) [PSPermGen: 2047K-&gt;2047K(2048K)], 0.0027156 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] https://www.viagrapascherfr.com/generique-viagra-tarif/[GC [PSYoungGen: 0K-&gt;0K(41728K)] 103K-&gt;103K(718976K), 0.0002800 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][Full GC [PSYoungGen: 0K-&gt;0K(41728K)] [PSOldGen: 103K-&gt;102K(677248K)] 103K-&gt;102K(718976K) [PSPermGen: 2047K-&gt;2047K(2048K)], 0.0044607 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Error occurred during initialization of VMjava.lang.OutOfMemoryError: PermGen space at java.lang.StringCoding.encode(StringCoding.java:266) at java.lang.String.getBytes(String.java:947) at java.lang.ClassLoader$NativeLibrary.load(Native Method) at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1778) at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1695) at java.lang.Runtime.loadLibrary0(Runtime.java:823) at java.lang.System.loadLibrary(System.java:1030) at java.lang.System.initializeSystemClass(System.java:1077) 从日志中可以看到由于产生大量的类，撑爆了永久区。同时还可以看到永久区的回收日志，说明永久去是回收的。 栈大小分配 -Xss 设置栈帧的深度，以K为单位 可以通过减小栈帧深度，来人为的造成StackOverflowError。 设置-Xss128K -XX:+PrintGCDetails参数来运行下面的代码 public class Demo10 { private static int count = 0; public static void recursion(long a,long b,long c){ long e=1,f=2,g=3,h=4,i=5,k=6,q=7,x=8,y=9,z=10; count++; recursion(a,b,c); } public static void main(String[] args) { try{ recursion(0L,0L,0L); }catch (StackOverflowError e) { System.out.println(count); e.printStackTrace(); } } } GC日志： 307java.lang.StackOverflowError at cn.xiuyu.jvm.head.Demo10.recursion(Demo10.java:9) 可以看到，递归调用了307次就抛出了StackOverflowError，如果把栈帧深度设置为256K，那么 762java.lang.StackOverflowError at cn.xiuyu.jvm.head.Demo10.recursion(Demo10.java:9)]]></content>
      <categories>
        <category>JVM系列（四）JVM配置参数</category>
      </categories>
      <tags>
        <tag>JVM系列（四）JVM配置参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列（三）GC算法 GC收集器]]></title>
    <url>%2F2017%2F05%2F26%2Fjvm-e7-b3-bb-e5-88-97-ef-bc-88-e4-b8-89-ef-bc-89gc-e7-ae-97-e6-b3-95-gc-e6-94-b6-e9-9b-86-e5-99-a8%2F</url>
    <content type="text"><![CDATA[jvm中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方**法区中**，在程序运行期间，这部分内存的分配和使用都是动态的，垃圾回收器关注的也是这部分内存。 对象死了吗？上文中说到了对象GC过程，其中对象符合了GC条件就会被垃圾回收器（GC回收器）所回收。那么怎么才算符合GC条件呢？在Java中一个对象只要被指针指向（也就是还有对象引用）那么这个对象就是个‘活对象’，反之，即为‘死对象’。那么怎么确定对象是否还被指针指向呢？这里有两种算法来确定对象是否被指针指向： 引用计数法：给对象添加一个引用计数器，每当有地方引用该对象时，计数器+1。但引用失效时，计数器-1。 可达性分析算法：通过“GC ROOT”对象作为起始点，从这些起始点向下搜索，搜索的路径成为引用链。当一个对象没有与任何引用链相连时，那么这个对象就为“死对象”。Java判断对象是否存活，使用的就是可达性分析算法。 那么那些对象可以称为GC ROOT对象呢 虚拟机栈中引用的对象。 方法区中类静态属性实体引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI引用的对象。 垃圾回收算法根据对象存活周期不同把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。这种垃圾回收方式就是分代收集。那么接下来详细说说各种垃圾回收算法。 标记-清理 “标记-清除”（Mark-Sweep）算法，如它的名字一样，标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。它是最基础的收集算法，后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。 它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 标记-压缩算法 标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。 复制算法 与标记-清除算法相比，复制算法是一种相对高效的回收方法，不适用于存活对象较多的场合 如老年代。将原有的内存空间分为两块（From Survivor空间、To Survivor空间），每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。 Stop The Wordstop the word是指在GC过程中，停止掉所有用户线程，只有一条线程去执行垃圾收集工作。它在进行垃圾收集工作时，必须站停掉所有的工作线程，直到他收集结束。stop the word是Java中一种全局暂停的现象。很容易理解为什么在GC过程中需要“stop the word”，–类比在聚会时打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。同时stop the word也会带来一定的危害：譬如 长时间服务停止，没有响应或者是–遇到HA系统，可能引起主备切换，严重危害生产环境。 垃圾回收器Serial收集器 串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停） 参数控制：-XX:+UseSerialGC串行收集器 ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩 参数控制： -XX:+UseParNewGCParNew收集器 -XX:ParallelGCThreads 限制线程数量 Parallel收集器 Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩 参数控制：-XX:+UseParallelGC 使用Parallel收集器+ 老年代串行 Paralle**l** Old 收集器 Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供 参数控制： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行 CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew） 优点:并发收集、低停顿 缺点：产生大量空间碎片**、**并发阶段会降低吞吐量 参数控制：-XX:+UseConcMarkSweepGC 使用CMS收集器 -XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长 -XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后，进行一次碎片整理 -**XX:ParallelCMSThreads ** 设定CMS的线程数量（一般情况约等于可用CPU数量） G1**收集器** G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点： 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。 G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。 收集步骤： 1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark) 2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。 3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。 4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。 5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。 6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。 收集器组合 单核单线程：Serial + Serial Old 多核多线程：ParNew + CMS 吞吐量：Parallel Scavenge + Parallel old 停顿时间：ParNew + CMS 或者是 G1 +G1]]></content>
      <categories>
        <category>JVM系列（三）GC算法 GC收集器</category>
      </categories>
      <tags>
        <tag>JVM系列（三）GC算法 GC收集器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列（二）JVM内存结构]]></title>
    <url>%2F2017%2F05%2F21%2Fjvm-e7-b3-bb-e5-88-97-ef-bc-88-e4-ba-8c-ef-bc-89jvm-e5-86-85-e5-ad-98-e7-bb-93-e6-9e-84%2F</url>
    <content type="text"><![CDATA[Java虚拟机在执行Java程序的过程会把他所管理的内存划分为若干个不同的数据区，这些区域都有各自的用途，以及创建和销毁时间。有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。 运行时数据区Java虚拟机会包括以下几个数据区（图一）： 绿色部分的方法区和堆是线程共享区域，而Java栈丶本地方法栈丶和程序计数器是线程私有区域。 下面我们详细介绍一下各个区域。 程序计数器（Program Counter Register）程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。这个区域是Java虚拟机唯一没有规定任何OutOfMemoryError情况的区域。 JVM栈（JVM Stacks）与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 本地方法栈（Native Method Stacks）本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 Java**堆（Heap）**对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中**最大**的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，**几乎所有的对象实例都在这里分配内存。** Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“**GC堆**”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：**新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。** 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区（Method Area） 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。 Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池运行时常量池是方法区的一部分。CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。 节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。 节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。 直接内存 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。这块区域在动态扩展内存是也会抛出OutOfMemoryError异常。 JavaGC内存结构Java的GC内存结构包含如下部分（图二）： 图一与图二的区别在于： 图一描述了jvm虚拟机与系统调用的关系，强调的是JVM区域。而图二描述的是垃圾回收(GC)触发的内存自动管理，细化了Java堆，略去了一些区域，强调的是GC内存管理。 图二内存结构主要有三大块：堆内存、方法区和栈。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配；方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。 对象的创建与回收过程： Java中大部分对象出生都会在Eden空间出生（部分大对象会在老年代出生，这里的大对象表示连续的数组对象），在几次GC后或者是GC过程中会从Eden空间转移到From Survivor空间。如果这次GC符合GC条件，会将该对象GC回收掉。如果不符合GC条件，会把该对象从From Survivor空间移动到To Survivor空间。完成一次GC，该对象的年龄会+1 。如果多次GC后，如果该对象的年龄到达一定的值（默认值为15），会将该对象移动到老年代空间。当然对象即使不到‘15’岁，也有可能被移动到老年代，如果 在Survivor空间中年龄相同所有对象的总和大于Survivor空间的一半，那么大于或者等于该年龄的对象就可以进入老年代空间。]]></content>
      <categories>
        <category>JVM系列（二）JVM内存结构</category>
      </categories>
      <tags>
        <tag>JVM系列（二）JVM内存结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客环境改为Liunx]]></title>
    <url>%2F2017%2F05%2F21%2Fe5-8d-9a-e5-ae-a2-e7-8e-af-e5-a2-83-e6-94-b9-e4-b8-baliunx%2F</url>
    <content type="text"><![CDATA[以前博客放在win环境下，phpstudy傻瓜式搞定（哈哈哈。但是最近出来莫名其妙的数据库访问不到或者是得到不到数据库的链接。google了一下，大部分的答案是网络防火墙问题要不就是重启一下，多次配置配置防火墙然后重启，治标不治本。索性把博客换成了Liunx，在搬博客的时候确实出了一些问题，把出现问题记录和安装配置环境的命令一下，方便下次搬（哈哈哈。 首先在win下把数据库导出和程序备份压缩阿，然后提交腾讯云工单重装成Linux系统（Ubuntu，主要是用着顺手）。然后其他乱七八糟的就略过，反正也是有些没有营养的东西。 准备工作1，重装完成后，登陆Ubuntu，想着先换个源吧。vim /etc/apt/sources.list 看样子应该是腾讯云的源，我这股子机灵劲又出来了：我这个是腾讯云的主机，而腾讯云的源应该和我这个在同一个内网，所以还是不换了 2，更新系统资源sudo apt-get update &amp;&amp; sudo apt-get upgrade LAMP环境apache2 sudo apt-get install apache2 php7 sudo apt-get install php7.0 整合apahce和php7 sudo apt-get install libapache2-mod-php7.0sudo service apache2 restart 现在可以测试一下apache和php环境是否可用，在/var/www/html文件夹下touch一个php文件。 touch 1.phpvim 1.php&lt;?phpphpinfo();?&gt; 然后打开浏览器，输入外网地址，如果是本地那就是localhost。看到下面页面说明成功了。（当然，你也可以在/etc/apache2/apache2.conf文件中进行一些自定义的配置，譬如端口，网站程序位置等。我这里都是默认，别问我为什么，我不会告诉因为懒！） 继续安装mysql sudo apt-get install mysql-server 当然mysql需要和php整合一下 sudo apt-get install php7.0-mysql 其他环境配置OK了，接下来就是上传程序导入数据库了，我用的SecureCRT所以装一个lrzsz sduo apt-get install lrzsz 哎呀！一个rz命令，选中 文件 点击上传，美滋滋！ 导入数据库，我用命令resource导入老是出错，如果用sqlyog远程连接，有需要改mysql的host。我怕出现一些玄学的问题。还是装一个phpmyadmin。 sudo apt-get install phpmyadmin 安装完后默认的安装位置是在/usr/share 而不是在/var/www 所以 需要将其链接到/var/www/html来，复制的话貌似需要改配置文件，相当麻烦。所以我选择链接 sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin 然后通过phpmyadmin导入数据库，全绿，看着就干爽。 问题程序搬家成功了！紧接着问题出现了：发现主页可以访问，但是自定义的链接和文章并不能访问提示404。而这个404并不是wordpress的404页面而是服务器的404。 服务器404首先要用命令： sudo a2enmod rewrite开启位于/etc/apache2/mods_avilable里面的rewrite模块 vim /etc/apache2/apache2.conf ​把&lt;Directory /var/www/&gt;里面的#AllowOverride None#改为#AllowOverride All# 没有权限上传文件当对后台各个功能进行测试时，发现图片文件上传失败，提示没有权限。好吧，提高对uploads提高权限。 sudo chmod 777 uploads OK！问题解决。(逃]]></content>
      <categories>
        <category>博客环境改为Liunx</category>
      </categories>
      <tags>
        <tag>博客环境改为Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列（一）类的加载机制]]></title>
    <url>%2F2017%2F05%2F12%2Fjvm-e7-b3-bb-e5-88-97-ef-bc-88-e4-b8-80-ef-bc-89-e7-b1-bb-e7-9a-84-e5-8a-a0-e8-bd-bd-e6-9c-ba-e5-88-b6%2F</url>
    <content type="text"><![CDATA[虚拟机把编译后的class文件加载到内存中，并对class文件进行校验，转换解析和初始化。最终执行可以直接被虚拟机使用的Java类型，这就是虚拟机的加载机制。在java语言中，类型的加载链接和初始化都是在运行时期完成，这种策略会稍微增加一些性能的开销，但是为Java程序提供了高度灵活性。JSP的热部署和OSGI技术都是使用了运行时期的类加载。 类的生命周期 类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。当解析在初始化之后执行时，称为动态绑定或者晚期绑定，例如：晚期绑定的多态特性。 1：加载主要是查找和加载二进制数据的过程，这里虚拟机会完成3件事： 通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 这里加载二进制并没有强制从class文件中获取，也可以从zip包，网络中获取，也可以通过计算生成，譬如动态代理技术，或者是其他文件生成，譬如jsp文件生成对应的class类。加载阶段完成之后虚拟机将二进制字节流按照虚拟机格式存放在方法区中，然后在内存中虚拟出一个Class对象（在HotSport中，Class对象比较特殊，虽然是对象，但是存放在方法区中）。 2：链接2.1 验证：验证是虚拟机链接的第一步，这一步主要是为了确保Class文件字节流的信息是否符合当前虚拟机的规范，并确保不会危害虚拟机自身的安全。验证阶段大约分为四个阶段的校验：文件格式校验，元数据验证，字节码验证，符号引用验证。 文件格式校验：是否符合Class文件规范，并且能被当前虚拟机处理 元数据验证：对字节码的信息进行语义分析 字节码验证：通过对数据流和控制流分析，确定程序语义时候合法，符合逻辑。完成之后还会对类的方法体进行验证分析，保证方法在运行时不会危害虚拟机。 符号引用验证：虚拟机将符号引用转换为直接引用。 2.2 准备：正式为类分配内存并设置类变量初始值，这些变量将会在方法区内分配内存。 public int value = 123;public static int value = 123;public static final int value = 123; 上面第一条语句在准备阶段过后初始值会被复制为0，在对象被new出来之后才会赋值为123。第二句虽然被static修饰，但是在准备阶段过后，初始值也是0，他会在类初始化时被赋值为123。第三句同时被static final修饰，他会在准备阶段将value赋值为123。 2.3 解析:虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 3：初始化初始化阶段是类加载的最后一个阶段，在初始化阶段其实就是初始化类变量和其它资源，某种角度来说就是类构造器Clinit()方法的执行过程，Clinit()大约就下面这几件事： 为静态属性和静态语句块属性赋值 确保类的构造器中显式调用父类构造器（保证父类比之类初始化早）。 初始化一个类时，保证单线程去初始化，其他线程需要堵塞。 4：使用经过上面处理的ByteCode要不解释执行，要不翻译成机器码，取指执行。 5：卸载 有启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范) 被系统类加载器和标准扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者标准扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小.(当然，在虚拟机快退出的时候可以，因为不管ClassLoader实例或者Class(java.lang.Class)实例也都是在堆中存在，同样遵循垃圾收集的规则). 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到.可以预想，稍微复杂点的应用场景中(尤其很多时候，用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的). 类加载器 “通过一个类的全限定名来获取该类的二进制字节流”这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何获取所需要的类，实现这个动作的代码模块就是“类加载器”。Java的虚拟机叫JVM。当我们在命令行执行 java HelloWord的时候，JVM干了下面几件事，也就是类加载过程： 产生一个Bootstrap Loader（引导类加载器） Bootstrap Loader（引导类加载器）自动加载Extended Loader（标准扩展类加载器），并将其父Loader设为Bootstrap Loader。 Bootstrap Loader（引导类加载器）自动加载AppClass Loader（系统类加载器），并将其父Loader设为Extended Loader。 最后由AppClass Loader加载HelloWorld类。 下面就是各个加载器之间的层次关系，这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的 站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现，是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。这些加载器可以分为一下三种类加载器： 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型从上图中可以看到类加载器之间的层次关系，这种层次关系称为双亲委派模型。（这种关系并不是通过继承实现，而是通过组合实现）。双亲委派模型除了顶层启动类加载器之外，其余的都要有自己的父类加载器。双亲委派的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 在JVM中具体的过程就是： 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载； 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 双亲委派模型的实现：public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException { return loadClass(name, false); } protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException { // 首先判断该类型是否已经被加载 Class c = findLoadedClass(name); if (c == null) { //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载 try { if (parent != null) { //如果存在父类加载器，就委派给父类加载器加载 c = parent.loadClass(name, false); } else { //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name) c = findBootstrapClass0(name); } } catch (ClassNotFoundException e) { // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能 c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } jvm加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。 自定义类加载器通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，我们应该把加载类的业务逻辑在线findClass()方法中，在从上面loadClass源码里面可以看到如果没有父类加载失败，会调用findClass方法来完成加载。这样我们写出来的自定义类加载器就不会破坏双亲委派模型。这里我们只关注核心内容就是对字节码文件的获取。 public class MyClassLoader extends ClassLoader{ private String root; public void setRoot(String root) { this.root = root; } @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { byte[] classData = loadClassData(name); if (classData == null) { return super.findClass(name); } else { return defineClass(name, classData, 0, classData.length); } } private byte\[\] loadClassData(String className){ try { String fileName = root + File.separatorChar + className.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;; InputStream input = new FileInputStream(fileName); ByteArrayOutputStream out = new ByteArrayOutputStream(); byte\[\] buff = new byte\[1024\]; int length = 0; while((length = input.read(buff))&gt;0){ out.write(buff, 0, length); } return out.toByteArray(); } catch (Exception e) { e.printStackTrace(); } return null; } public static void main(String\[\] args) throws Exception { MyClassLoader loader = new MyClassLoader(); loader.setRoot(&quot;E:/&quot;); Object o = loader.loadClass(&quot;cn.xiuyu.loader.TestClass&quot;); System.out.println(o); } }]]></content>
      <categories>
        <category>JVM系列（一）类的加载机制</category>
      </categories>
      <tags>
        <tag>JVM系列（一）类的加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAOP源码分析系列]]></title>
    <url>%2F2017%2F05%2F04%2Fspringaop-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-e7-b3-bb-e5-88-97%2F</url>
    <content type="text"><![CDATA[AOP（Aspect Orient Programming），作为面向对象编程的一种补充，广泛应用于处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等。AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类，其中静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。 AOP 的存在价值在传统 OOP 编程里以对象为核心，整个软件系统由系列相互依赖的对象所组成，而这些对象将被抽象成一个一个的类，并允许使用类继承来管理类与类之间一般到特殊的关系。随着软件规模的增大，应用的逐渐升级，慢慢出现了一些 OOP 很难解决的问题。 我们可以通过分析、抽象出一系列具有一定属性与行为的对象，并通过这些对象之间的协作来形成一个完整的软件功能。由于对象可以继承，因此我们可以把具有相同功能或相同特性的属性抽象到一个层次分明的类结构体系中。随着软件规范的不断扩大，专业化分工越来越系列，以及 OOP 应用实践的不断增多，随之也暴露出了一些 OOP 无法很好解决的问题。 现在假设系统中有 3 段完全相似的代码，这些代码通常会采用“复制”、“粘贴”方式来完成，通过这种“复制”、“粘贴”方式开发出来的软件如图 1 所示。 图 1.多个地方包含相同代码的软件 看到如图 1 所示的示意图，可能有的读者已经发现了这种做法的不足之处：如果有一天，图 1 中的深色代码段需要修改，那是不是要打开 3 个地方的代码进行修改？如果不是 3 个地方包含这段代码，而是 100 个地方，甚至是 1000 个地方包含这段代码段，那会是什么后果？ 为了解决这个问题，我们通常会采用将如图 1 所示的深色代码部分定义成一个方法，然后在 3 个代码段中分别调用该方法即可。在这种方式下，软件系统的结构如图 2 所示。 图 2 通过方法调用实现系统功能 对于如图 2 所示的软件系统，如果需要修改深色部分的代码，只要修改一个地方即可，不管整个系统中有多少地方调用了该方法，程序无须修改这些地方，只需修改被调用的方法即可——通过这种方式，大大降低了软件后期维护的复杂度。 对于如图 2 所示的方法 1、方法 2、方法 3 依然需要显式调用深色方法，这样做能够解决大部分应用场景。但对于一些更特殊的情况：应用需要方法 1、方法 2、方法 3 彻底与深色方法分离——方法 1、方法 2、方法 3 无须直接调用深色方法，那如何解决？ 因为软件系统需求变更是很频繁的事情，系统前期设计方法 1、方法 2、方法 3 时只实现了核心业务功能，过了一段时间，我们需要为方法 1、方法 2、方法 3 都增加事务控制；又过了一段时间，客户提出方法 1、方法 2、方法 3 需要进行用户合法性验证，只有合法的用户才能执行这些方法；又过了一段时间，客户又提出方法 1、方法 2、方法 3 应该增加日志记录；又过了一段时间，客户又提出……面对这样的情况，我们怎么办？通常有两种做法： 根据需求说明书，直接拒绝客户要求。 拥抱需求，满足客户的需求。 第一种做法显然不好，客户是上帝，我们应该尽量满足客户的需求。通常会采用第二种做法，那如何解决呢？是不是每次先定义一个新方法，然后修改方法 1、方法 2、方法 3，增加调用新方法？这样做的工作量也不小啊！我们希望有一种特殊的方法：我们只要定义该方法，无须在方法 1、方法 2、方法 3 中显式调用它，系统会“自动”执行该特殊方法。 上面想法听起来很神奇，甚至有一些不切实际，但其实是完全可以实现的，实现这个需求的技术就是 AOP。AOP 专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在 Java EE 应用中，常常通过 AOP 来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP 已经成为一种非常常用的解决方案。 本片系列文章参考主要spring技术内幕一书，还有网络上的一些博客，这里就不一一列举了。本来我是写在word中，然后搬到了blog中。适合于想研究AOP源码或想深入学习一下AOP的话，可以参考本系列文章。如果有哪里不对，欢迎指出感激不尽。 本系列的文章都是基于Spring4.3.3.RELEASE版本的 文章阅读顺序：Spring源码分析-AOP（一）预备知识 Spring源码分析-AOP（二）入门 Spring源码分析-AOP（三）XML解析 Spring源码分析-AOP（四）匹配Advisor Spring源码分析-AOP（五）创建增强对象 Spring源码分析-AOP（六）拦截器调用 Spring源码分析-AOP（七）AOP小结]]></content>
      <categories>
        <category>SpringAOP源码分析系列</category>
      </categories>
      <tags>
        <tag>SpringAOP源码分析系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-AOP（七）AOP小结]]></title>
    <url>%2F2017%2F05%2F04%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-aop-ef-bc-88-e4-b8-83-ef-bc-89aop-e5-b0-8f-e7-bb-93%2F</url>
    <content type="text"><![CDATA[在我们看到的AOP部分源码中，可以看到 Proxy 代理对象的使用，在程序中是一个非常重要的部分，Spring AOP 充分利用 Java 的Proxy、反射以及第三方的 CGLIB 这些方案，通过这些技术，完成了 AOP 代理对象的生成。 个人觉得可以分为三个部分，IOC容器初始化，代理对象初始化和创建，执行代理对象。 1,IOC容器初始化 在IOC容器初始化的时候解析XML遇到命名空间就会去找命名空间对应的Handler处理，解析不同的标签调用不同的parse,这里找到的是AopNamespaceHandler调用的ConfigBeanDefinitionParser，在其Parser方法中注册了一个AspectJAwareAdvisorAutoProxyCreator类，解析了AOP相关的标签。譬如aop:pointcutaop:aspect等。 2,代理对象初始化和创建因为我们向容器注册了一个AspectJAwareAdvisorAutoProxyCreator类，所以我们在创建Bean的时候会执行postProcessBeforeInstantiation方法。所以当我们第一次getBean的时候（也就是创建Bean的时候），会调用postProcessBeforeInstantiation方法。这个方法干了3件事： 1,获取Bean对应的Advisor。 2,获取所有匹配Bean的Advisor，使用AspectJExpressionPointcut 匹配。 3,创建代理对象，如果被对象继承接口就是用JDK代理，否则默认使用CGLIB。 执行代理对象 这里用JDK为例，因为JdkDynamicAopProxy实现了InvocationHandler接口，这就说明每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。 invoke方法做了这几件事： 1，获取所有的Advisor，封装到ReflectiveMethodInvocation中形成拦截器链。 2，如果连接器链为空就执行代理方法。 3，如果有拦截器，通过InterceptorAndDynamicMethodMatcher 匹配，匹配成功就在拦截器类进行逻辑调用。 Spring AOP 源码分析 在 Spring AOP 的基本实现中，我们可以看到 Proxy 代理对象的使用，在程序中是一个非常重要的部分，Spring AOP 充分利用 Java 的Proxy、反射以及第三方的 CGLIB 这些方案，通过这些技术，完成了 AOP AopProxy 代理对象的生成。 回顾整个源码实现过程我们可以看到，首先在容器初始化时解析标签注册自动代理创建器AspectJAwareAdvisorAutoProxyCreator。在创建初始化和创建Bean的时候，通过BeanFactoryAdvisorRetrievalHelper 获取所有Bean相关的Advisor，使用AspectJExpressionPointcut 进行匹配Advisor，从而获得匹配的Advisor，最后通过ProxyFactory 创建代理对象。 而最终 AopProxy 代理对象的产生，会交给 JdkDynamicAopProxy 和 CglibAopProxy 这两个工厂来完成，用的就是我们最开始说到的技术。 在完成 AopProxy 代理对象后，我们就可以对 AOP 切面逻辑进行实现了，首先会对这些方法进行拦截，从而为这些方法提供工作空间，随后在进行回调，从而完成 AOP 切面实现的一整个逻辑。而这里的拦截 JdkDynamicAopProxy 主要是通过内部的 invoke 方法来实现，而 CGLIB 是通过 getCallbacks 方法来完成的。他们为 AOP 切面的实现提供了舞台。 总结Spring AOP 秉承 Spring 一贯的设计理念，致力于 AOP 框架与 IOC 容器的紧密集成，以此来为 J2EE 的开发人员服务。这里仅仅介绍了一部分，还有很多地方都很值得大家去仔细专研。当然，AOP 的实现时一个三足鼎立的世界：AspectJ、JBoss AOP、Spring AOP。如果你有兴趣，除了 Spring AOP 以外 AspectJ 和 JBoss AOP 是非常值得大家研究以及借鉴的。 特别是 AspectJ。我们知道 Spring 的增强都是用标准的 Java 类编写的。我们可以用一般的 Java 开发环境进行开发切面，虽然好用，但是开发人员必须对 Java 开发相当熟悉，仅仅使用 Java 也有一定的局限性。而 AspectJ 与之相反，他专注于切面的开发，虽然最初也仅仅是作为 Java 语言的扩展方式来实现，但通过特有的 AOP 语言，我们可以获得更强大以及细颗粒的控制，从而丰富了 AOP 工具集。所以 Spring AOP 为弥补自身的不足，在源码中集成了 AspectJ 框架，有兴趣大家也可以去研究一下。]]></content>
      <categories>
        <category>Spring源码分析-AOP（七）AOP小结</category>
      </categories>
      <tags>
        <tag>Spring源码分析-AOP（七）AOP小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-AOP（六）拦截器调用]]></title>
    <url>%2F2017%2F05%2F03%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-aop-ef-bc-88-e5-85-ad-ef-bc-89-e6-8b-a6-e6-88-aa-e5-99-a8-e8-b0-83-e7-94-a8%2F</url>
    <content type="text"><![CDATA[可以看到JdkDynamicAopProxy实现了InvocationHandler接口，这就说明每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。我们来看看InvocationHandler这个接口的唯一一个方法 invoke 方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { MethodInvocation invocation; Object oldProxy = null; boolean setProxyContext = false; TargetSource targetSource = this.advised.targetSource; Class&lt;?&gt; targetClass = null; Object target = null; try { //equals方法的处理 if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) { // The target does not implement the equals(Object) [cialisfrance24.com](http://cialisfrance24.com/) method itself. return equals(args\[0\]); } //hashCode方法的处理 else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) { // The target does not implement the hashCode() method itself. return hashCode(); } else if (method.getDeclaringClass() == DecoratingProxy.class) { // There is only getDecoratedClass() declared -&gt; dispatch to proxy config. return AopProxyUtils.ultimateTargetClass(this.advised); } //根据代理对象配置调用服务 else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) { // Service invocations on ProxyConfig with the proxy config... return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args); } Object retVal; //当目标对象内部的自我调用无法实施切面中的增强则需要增强则需要通过此属性暴露代理 if (this.advised.exposeProxy) { // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; } // May be null. Get as late as possible to minimize the time we &quot;own&quot; the target, // in case it comes from a pool. target = targetSource.getTarget(); if (target != null) { targetClass = target.getClass(); } // Get the interception chain for this method. //获取当前方法的拦截器调用 List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); // Check whether we have any advice. If we don&apos;t, we can fallback on direct // reflective invocation of the target, and avoid creating a MethodInvocation. //如果没有发现拦截器则直接调用切点方法 if (chain.isEmpty()) { // We can skip creating a MethodInvocation: just invoke the target directly // Note that the final invoker must be an InvokerInterceptor so we know it does // nothing but a reflective operation on the target, and no hot swapping or fancy proxying. Object\[\] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse); } else { //将拦截器封装在 ReflectiveMethodInvocation // We need to create a method invocation... invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); // Proceed to the joinpoint through the interceptor chain. //执行拦截器链 retVal = invocation.proceed(); } // Massage return value if necessary. Class&lt;?&gt; returnType = method.getReturnType(); //返回结果 if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) { // Special case: it returned &quot;this&quot; and the return type of the method // is type-compatible. Note that we can&apos;t help if the target sets // a reference to itself in another returned object. retVal = proxy; } else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) { throw new AopInvocationException( &quot;Null return value from advice does not match primitive return type for: &quot; + method); } return retVal; } finally { if (target != null &amp;&amp; !targetSource.isStatic()) { // Must have come from TargetSource. targetSource.releaseTarget(target); } if (setProxyContext) { // Restore old proxy. AopContext.setCurrentProxy(oldProxy); } } } 上面的主要工作就是创建一个拦截链，通过ReflectiveMethodInvocation来封装并通过proceed来执行拦截器，那么其内部如何实现？ public Object proceed() throws Throwable { // We start with an index of -1 and increment early. //执行完所有增强后执行切点 if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) { return invokeJoinpoint(); } //获取下一个要执行的拦截器 Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) { // Evaluate dynamic method matcher here: static part will already have // been evaluated and found to match. //动态匹配 InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice; if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) { return dm.interceptor.invoke(this); } else { // Dynamic matching failed. // Skip this interceptor and invoke the next in the chain. //不匹配则不执行 return proceed(); } } else { //如果是个普通拦截器则直接执行invoke方法。 // It&apos;s an interceptor, so we just invoke it: The pointcut will have // been evaluated statically before this object was constructed. return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); } } ReflectiveMethodInvocation内部就是维护了一个计数器，并且记录当前链接的位置，以便链的有序的执行下去。把增强的工作交个每个拦截器，使各个拦截器在内部进行逻辑执行。 CglibAopProxy是通过getCallbacks方法设置拦截器链的。 private Callback[] getCallbacks(Class&lt;?&gt; rootClass) throws Exception { //对于expose-proxy属性的处理 // Parameters used for optimisation choices… boolean exposeProxy = this.advised.isExposeProxy(); boolean isFrozen = this.advised.isFrozen(); boolean isStatic = this.advised.getTargetSource().isStatic(); //将拦截器封装在DynamicAdvisedInterceptor中 // Choose an &quot;aop&quot; interceptor (used for AOP calls). Callback aopInterceptor = new DynamicAdvisedInterceptor(this.advised); // Choose a &quot;straight to target&quot; interceptor. (used for calls that are // unadvised but can return this). May be required to expose the proxy. Callback targetInterceptor; if (exposeProxy) { targetInterceptor = isStatic ? new StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) : new DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource()); } else { targetInterceptor = isStatic ? new StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) : new DynamicUnadvisedInterceptor(this.advised.getTargetSource()); } // Choose a &quot;direct to target&quot; dispatcher (used for // unadvised calls to static targets that cannot return this). Callback targetDispatcher = isStatic ? new StaticDispatcher(this.advised.getTargetSource().getTarget()) : new SerializableNoOp(); Callback\[\] mainCallbacks = new Callback\[\] { //将拦截器加入Callback aopInterceptor, // for normal advice targetInterceptor, // invoke target without considering advice, if optimized new SerializableNoOp(), // no override for methods mapped to this targetDispatcher, this.advisedDispatcher, new EqualsInterceptor(this.advised), new HashCodeInterceptor(this.advised) }; Callback\[\] callbacks; // If the target is a static one and the advice chain is frozen, // then we can make some optimisations by sending the AOP calls // direct to the target using the fixed chain for that method. if (isStatic &amp;&amp; isFrozen) { Method\[\] methods = rootClass.getMethods(); Callback\[\] fixedCallbacks = new Callback\[methods.length\]; this.fixedInterceptorMap = new HashMap&lt;String, Integer&gt;(methods.length); // TODO: small memory optimisation here (can skip creation for methods with no advice) for (int x = 0; x &lt; methods.length; x++) { List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(methods\[x\], rootClass); fixedCallbacks\[x\] = new FixedChainStaticTargetInterceptor( chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass()); this.fixedInterceptorMap.put(methods\[x\].toString(), x); } // Now copy both the callbacks from mainCallbacks // and fixedCallbacks into the callbacks array. callbacks = new Callback\[mainCallbacks.length + fixedCallbacks.length\]; System.arraycopy(mainCallbacks, 0, callbacks, 0, mainCallbacks.length); System.arraycopy(fixedCallbacks, 0, callbacks, mainCallbacks.length, fixedCallbacks.length); this.fixedInterceptorOffset = mainCallbacks.length; } else { callbacks = mainCallbacks; } return callbacks; } 上面将拦截器链封装在DynamicAdvisedInterceptor中并且加入到Callback中，众所周知，cglib对方法的调用是通过实现methodintercept的拦截器加入Callback并且在调用代理时调用intercept方法。这里的DynamicAdvisedInterceptor继承methodintercept，在调用代理时会直接调用DynamicAdvisedInterceptor的intercept方法。 public Object intercept(Object proxy, Method method, Object\[\] args, MethodProxy methodProxy) throws Throwable { Object oldProxy = null; boolean setProxyContext = false; Class&lt;?&gt; targetClass = null; Object target = null; try { if (this.advised.exposeProxy) { // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; } // May be null. Get as late as possible to minimize the time we // &quot;own&quot; the target, in case it comes from a pool... target = getTarget(); if (target != null) { targetClass = target.getClass(); } //获取拦截器 List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); Object retVal; // Check whether we only have one InvokerInterceptor: that is, // no real advice, but just reflective invocation of the target. if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) { // We can skip creating a MethodInvocation: just invoke the target directly. // Note that the final invoker must be an InvokerInterceptor, so we know // it does nothing but a reflective operation on the target, and no hot // swapping or fancy proxying. //如果没有拦截器则直接调用原方法 Object\[\] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); retVal = methodProxy.invoke(target, argsToUse); } else { //调用链 // We need to create a method invocation... retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed(); } retVal = processReturnType(proxy, target, method, retVal); return retVal; } finally { if (target != null) { releaseTarget(target); } if (setProxyContext) { // Restore old proxy. AopContext.setCurrentProxy(oldProxy); } } } 与jdk调用拦截器链的方式大同小异，首先获取封装拦截器，在此链中进行串行调用。稍微有区别的就是在jdk中使用ReflectiveMethodInvocation构造，而cglib使用CglibMethodInvocation构造，ReflectiveMethodInvocation是CglibMethodInvocation的父类，而且CglibMethodInvocation的proceed并没有重写。可以看出spring的动态代理，就是在运行时通过匹配和执行各个链接器，实现代理对象增强。]]></content>
      <categories>
        <category>Spring源码分析-AOP（六）拦截器调用</category>
      </categories>
      <tags>
        <tag>Spring源码分析-AOP（六）拦截器调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-AOP（五）创建增强对象]]></title>
    <url>%2F2017%2F04%2F28%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-aop-ef-bc-88-e4-ba-94-ef-bc-89-e5-88-9b-e5-bb-ba-e5-a2-9e-e5-bc-ba-e5-af-b9-e8-b1-a1%2F</url>
    <content type="text"><![CDATA[上文中讲到了如何匹配Advisor，本文接着上文向下讲，继续回到postProcessBeforeInstantiation方法。 public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException { Object cacheKey = getCacheKey(beanClass, beanName); if (beanName == null || !this.targetSourcedBeans.contains(beanName)) { if (this.advisedBeans.containsKey(cacheKey)) { return null; } if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; } } // Create proxy here if we have a custom TargetSource. // Suppresses unnecessary default instantiation of the target bean: // The TargetSource will handle target instances in a custom fashion. if (beanName != null) { TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) { this.targetSourcedBeans.add(beanName); //获取所有的通知 Object\[\] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); //把所有的通知配置到代理类 Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } } return null; } 进一步看一下createProxy方法 protected Object createProxy( Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) { if (this.beanFactory instanceof ConfigurableListableBeanFactory) { AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); } //其实就是使用ProxyFactory来生成代理对象 ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); if (!proxyFactory.isProxyTargetClass()) { if (shouldProxyTargetClass(beanClass, beanName)) { proxyFactory.setProxyTargetClass(true); } else { evaluateProxyInterfaces(beanClass, proxyFactory); } } Advisor\[\] advisors = buildAdvisors(beanName, specificInterceptors); //把匹配的advisors添加到proxyFactory for (Advisor advisor : advisors) { proxyFactory.addAdvisor(advisor); } proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) { proxyFactory.setPreFiltered(true); } //获取代理对象 return proxyFactory.getProxy(getProxyClassLoader()); } public Object getProxy(ClassLoader classLoader) { return createAopProxy().getProxy(classLoader); } protected final synchronized AopProxy createAopProxy() { if (!this.active) { activate(); } return getAopProxyFactory().createAopProxy(this); } createAopProxy是AopProxyFactory接口的方法，其实现在DefaultAopProxyFactory public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) { Class&lt;?&gt; targetClass = config.getTargetClass(); if (targetClass == null) { throw new AopConfigException(“TargetSource cannot determine target class: “ + “Either an interface or a target is required for proxy creation.”); } if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) { return new JdkDynamicAopProxy(config); } return new ObjenesisCglibAopProxy(config); } else { return new JdkDynamicAopProxy(config); } } 从上面的代码可以看到，如果是个接口就用jdk代理，否则就用cglib代理生成对象。我们下看一下jdk代理如何实现的。 jdk代理jdk代理的实现类是JdkDynamicAopProxy，看一下调用的getProxy方法。 @Override public Object getProxy() { return getProxy(ClassUtils.getDefaultClassLoader()); } @Override public Object getProxy(ClassLoader classLoader) { if (logger.isDebugEnabled()) { logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource()); } Class&lt;?&gt;\[\] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); //调用jdk生成代理的地方 return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this); } cglib生成代理看一下ObjenesisCglibAopProxy的getProxy方法。 @Override public Object getProxy() { return getProxy(null); } @Override public Object getProxy(ClassLoader classLoader) { if (logger.isDebugEnabled()) { logger.debug(&quot;Creating CGLIB proxy: target source is &quot; + this.advised.getTargetSource()); } try { //advised取出ioc容器中配置的target对象 Class&lt;?&gt; rootClass = this.advised.getTargetClass(); Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;); Class&lt;?&gt; proxySuperClass = rootClass; if (ClassUtils.isCglibProxyClass(rootClass)) { proxySuperClass = rootClass.getSuperclass(); Class&lt;?&gt;\[\] additionalInterfaces = rootClass.getInterfaces(); for (Class&lt;?&gt; additionalInterface : additionalInterfaces) { this.advised.addInterface(additionalInterface); } } // Validate the class, writing log messages as necessary. validateClassIfNecessary(proxySuperClass, classLoader); // Configure CGLIB Enhancer... //创建并设置CGLIB的Enhancer，这个Enhancer对象是CGLIB的主要操作类 Enhancer enhancer = createEnhancer(); if (classLoader != null) { enhancer.setClassLoader(classLoader); if (classLoader instanceof SmartClassLoader &amp;&amp; ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) { enhancer.setUseCache(false); } } //设置Enhancer对象的各种属性 enhancer.setSuperclass(proxySuperClass); enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised)); enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader)); Callback\[\] callbacks = getCallbacks(rootClass); Class&lt;?&gt;\[\] types = new Class\[callbacks.length\]; for (int x = 0; x &lt; types.length; x++) { types\[x\] = callbacks\[x\].getClass(); } // fixedInterceptorMap only populated at this point, after getCallbacks call above enhancer.setCallbackFilter(new ProxyCallbackFilter( this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset)); enhancer.setCallbackTypes(types); // Generate the proxy class and create a proxy instance. //创建实现代理 return createProxyClassAndInstance(enhancer, callbacks); } catch (CodeGenerationException ex) { throw new AopConfigException(&quot;Could not generate CGLIB subclass of class \[&quot; + this.advised.getTargetClass() + &quot;\]: &quot; + &quot;Common causes of this problem include using a final class or a non-visible class&quot;, ex); } catch (IllegalArgumentException ex) { throw new AopConfigException(&quot;Could not generate CGLIB subclass of class \[&quot; + this.advised.getTargetClass() + &quot;\]: &quot; + &quot;Common causes of this problem include using a final class or a non-visible class&quot;, ex); } catch (Exception ex) { // TargetSource.getTarget() failed throw new AopConfigException(&quot;Unexpected AOP exception&quot;, ex); } } 上面其实就是干了两件事 1，把所有的advised封装到proxyFactory中。 2，如果被代理的对象实现接口，默认使用jdk的方式创建代理，否则就使用CGLIB方式创建。 至此，代理对象就被创建出来了！]]></content>
      <categories>
        <category>Spring源码分析-AOP（五）创建增强对象</category>
      </categories>
      <tags>
        <tag>Spring源码分析-AOP（五）创建增强对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-AOP（四）匹配Advisor]]></title>
    <url>%2F2017%2F04%2F27%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-aop-ef-bc-88-e5-9b-9b-ef-bc-89-e5-8c-b9-e9-85-8dadvisor%2F</url>
    <content type="text"><![CDATA[上文中讲到了如何解析config标签，并把XML文件中定义的属性设置到IOC容器中。在Spring源码分析-AOP（二）入门文章中讲到了在解析config标签之前，先注册一个AspectJAwareAdvisorAutoProxyCreator类型的类。从这个类的继承关系中看到它实现了BeanPostProcessor接口。 BeanPostProcessor接口作用是：如果我们需要在Spring容器完成Bean的实例化、配置和其他的初始化前后添加一些自己的逻辑处理，我们就可以定义一个或者多个BeanPostProcessor接口的实现，然后注册到容器中。所以在创建类之前会调用BeanPostProcessor的postProcessBeforeInstantiation方法。 当调用者通过 getBean（ name ）向 容器寻找Bean 时，如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor接口，在实例 bean 之前，将调用该接口的 postProcessBeforeInstantiation （）方法。AspectJAwareAdvisorAutoProxyCreator实现了InstantiationAwareBeanPostProcessor。所以当getBean时就会执行 postProcessBeforeInstantiation方法。 public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException { Object cacheKey = getCacheKey(beanClass, beanName); if (beanName == null || !this.targetSourcedBeans.contains(beanName)) { if (this.advisedBeans.containsKey(cacheKey)) { return null; } if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; } } // Create proxy here if we have a custom TargetSource. // Suppresses unnecessary default instantiation of the target bean: // The TargetSource will handle target instances in a custom fashion. if (beanName != null) { TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) { this.targetSourcedBeans.add(beanName); //获取所有的通知 Object\[\] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); //把所有的通知配置到代理类 Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } } return null; } getAdvicesAndAdvisorsForBean该方法是AbstractAutoProxyCreator的抽象方法，实现由子类实现。从继承的关系来看，这里的子类就是AbstractAdvisorAutoProxyCreator。 //调用入口 protected Object\[\] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) { List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName); if (advisors.isEmpty()) { return DO\_NOT\_PROXY; } return advisors.toArray(); } //查找适合的Advisorsprotected List findEligibleAdvisors(Class beanClass, String beanName) { List candidateAdvisors = findCandidateAdvisors(); List eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors);//交给子类实现扩展 if (!eligibleAdvisors.isEmpty()) { eligibleAdvisors = sortAdvisors(eligibleAdvisors); } return eligibleAdvisors;} 解析getAdvicesAndAdvisorsForBeanprotected List findEligibleAdvisors(Class beanClass, String beanName) { List candidateAdvisors = findCandidateAdvisors();//获取所有的Advisors if (advisors.isEmpty()) { return DO_NOT_PROXY; } return advisors.toArray();} protected List findCandidateAdvisors() { //委托给BeanFactoryAdvisorRetrievalHelper处理 return this.advisorRetrievalHelper.findAdvisorBeans(); } public List&lt;Advisor&gt; findAdvisorBeans() { // Determine list of advisor bean names, if not cached already. String\[\] advisorNames = null; synchronized (this) { advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) { // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the auto-proxy creator apply to them! //获取容器中声明的Advisor advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; } } if (advisorNames.length == 0) { return new LinkedList&lt;Advisor&gt;(); } List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;(); for (String name : advisorNames) { //判断返回 if (isEligibleBean(name)) { if (this.beanFactory.isCurrentlyInCreation(name)) { if (logger.isDebugEnabled()) { logger.debug(&quot;Skipping currently created advisor &apos;&quot; + name + &quot;&apos;&quot;); } } else { try { advisors.add(this.beanFactory.getBean(name, Advisor.class)); } catch (BeanCreationException ex) { Throwable rootCause = ex.getMostSpecificCause(); if (rootCause instanceof BeanCurrentlyInCreationException) { BeanCreationException bce = (BeanCreationException) rootCause; if (this.beanFactory.isCurrentlyInCreation(bce.getBeanName())) { if (logger.isDebugEnabled()) { logger.debug(&quot;Skipping advisor &apos;&quot; + name + &quot;&apos; with dependency on currently created bean: &quot; + ex.getMessage()); } // Ignore: indicates a reference back to the bean we&apos;re trying to advise. // We want to find advisors other than the currently created bean itself. continue; } } throw ex; } } } } return advisors; } 从上面的代码可以看到是如何获取所有的Advisor。回到AbstractAdvisorAutoProxyCreator的findAdvisorsThatCanApply方法，看他是如何进行匹配的。 匹配​findAdvisorsThatCanApply protected List findAdvisorsThatCanApply( List candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) { ProxyCreationContext.setCurrentProxiedBeanName(beanName); try { //定位到AopUtils.findAdvisorsThatCanApply return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass); } finally { ProxyCreationContext.setCurrentProxiedBeanName(null); } } public static List findAdvisorsThatCanApply(List candidateAdvisors, Class&lt;?&gt; clazz) { if (candidateAdvisors.isEmpty()) { return candidateAdvisors; } List eligibleAdvisors = new LinkedList(); //遍历 for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) { //是否IntroductionAdvisor eligibleAdvisors.add(candidate); } } boolean hasIntroductions = !eligibleAdvisors.isEmpty(); for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor) { // already processed continue; } //执行 if (canApply(candidate, clazz, hasIntroductions)) { eligibleAdvisors.add(candidate); } } return eligibleAdvisors; } public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) { //如果是IntroductionAdvisor则调用AspectJExpressionPointcut的matches方法 if (advisor instanceof IntroductionAdvisor) { return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass); } //如果是PointcutAdvisor则调用AspectJExpressionPointcut的matches方法（与上面相比非同一个方法） else if (advisor instanceof PointcutAdvisor) { PointcutAdvisor pca = (PointcutAdvisor) advisor; return canApply(pca.getPointcut(), targetClass, hasIntroductions); } else { // It doesn&apos;t have a pointcut so we assume it applies. return true; } } 这里的AspectJExpressionPointcut同时实现了MethodMatcher和ClassFilter两个接口。 public class AspectJExpressionPointcut extends AbstractExpressionPointcut implements ClassFilter, IntroductionAwareMethodMatcher, BeanFactoryAware { //ClassFilter实现 public boolean matches(Class targetClass) { checkReadyToMatch(); try { return this.pointcutExpression.couldMatchJoinPointsInType(targetClass); } catch (ReflectionWorldException e) { logger.debug(“PointcutExpression matching rejected target class”, e); } }//MethodMatcher实现public boolean matches(Method method, Class targetClass, boolean beanHasIntroductions) { checkReadyToMatch(); Method targetMethod = AopUtils.getMostSpecificMethod(method, targetClass); ShadowMatch shadowMatch = getShadowMatch(targetMethod, method); // Special handling for this, target, @this, @target, @annotation // in Spring - we can optimize since we know we have exactly this class, // and there will never be matching subclass at runtime. if (shadowMatch.alwaysMatches()) { return true; } else if (shadowMatch.neverMatches()) { return false; } else { // the maybe case return (beanHasIntroductions || matchesIgnoringSubtypes(shadowMatch) || matchesTarget(shadowMatch, targetClass)); }} } public class PointcutExpressionImpl implements PointcutExpression {//AspectJExpressionPointcut 实现ClassFilter接口时候调用。public boolean couldMatchJoinPointsInType(Class aClass) { ResolvedType matchType = world.resolve(aClass.getName()); ReflectionFastMatchInfo info = new ReflectionFastMatchInfo(matchType, null, this.matchContext, world); boolean couldMatch = pointcut.fastMatch(info).maybeTrue(); if (MATCH_INFO) { System.out.println(“MATCHINFO: fast match for ‘“ + this.expression + “‘ against ‘“ + aClass.getName() + “‘: “ + couldMatch); } return couldMatch;}} 看一下整个的执行流图时序图 具体实现逻辑，通过上面的分析就是表达式的使用。确定一个方法是否被应用于advice,其实就是根据PointCut与方法进行匹配。]]></content>
      <categories>
        <category>Spring源码分析-AOP（四）匹配Advisor</category>
      </categories>
      <tags>
        <tag>Spring源码分析-AOP（四）匹配Advisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-AOP（三）XML解析]]></title>
    <url>%2F2017%2F04%2F26%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-aop-ef-bc-88-e4-b8-89-ef-bc-89advices%2F</url>
    <content type="text"><![CDATA[上文在ico容器初始化时，注册了一个AspectJAwareAdvisorAutoProxyCreator类，也提到了容器初始化时解析aop:config标签会用AopNamespaceHandler调用ConfigBeanDefinitionParser的Parser方法。 @Override public BeanDefinition parse(Element element, ParserContext parserContext) { CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element)); parserContext.pushContainingComponent(compositeDef); // 创建AOP自动代理创建器 configureAutoProxyCreator(parserContext, element); //遍历并解析&lt;aop:config&gt;的子标签 List&lt;Element&gt; childElts = DomUtils.getChildElements(element); for (Element elt: childElts) { String localName = parserContext.getDelegate().getLocalName(elt); if (&quot;pointcut&quot;.equals(localName)) { // 解析&lt;aop:pointcut&gt;标签 parsePointcut(elt, parserContext); } else if (&quot;advisor&quot;.equals(localName)) { // 解析&lt;aop:advisor&gt;标签 parseAdvisor(elt, parserContext); } else if (&quot;aspect&quot;.equals(localName)) { // 解析&lt;aop:aspect&gt;标签 parseAspect(elt, parserContext); } } parserContext.popAndRegisterContainingComponent(); return null; } parse方法首先调用解析器ConfigBeanDefinitionParser的configureAutoProxyCreator方法来向容器中注册一个自动代理构建器AspectJAwareAdvisorAutoProxyCreator对象，然后调用parsePointcut方法解析aop:pointcut标签，调用parseAdvisor方法解析aop:advisor标签，调用parseAspect方法解析aop:aspect标签。 解析aop:config属性想容器注册了AspectJAwareAdvisorAutoProxyCreator对象之后，接着调用AopNamespaceUtils中useClassProxyingIfNecessary方法来解析aop:config的两个属性。 private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, Element sourceElement) { if (sourceElement != null) { // 解析proxy-target-class属性 boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE)); if (proxyTargetClass) { AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); } // 解析expose-proxy属性 boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE)); if (exposeProxy) { AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); } } } 在是对两个属性的处理 public static final String AUTO_PROXY_CREATOR_BEAN_NAME = “org.springframework.aop.config.internalAutoProxyCreator”;public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) { if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) { BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME); definition.getPropertyValues().add(“proxyTargetClass”, Boolean.TRUE); } } public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) { if (registry.containsBeanDefinition(AUTO\_PROXY\_CREATOR\_BEAN\_NAME)) { BeanDefinition definition = registry.getBeanDefinition(AUTO\_PROXY\_CREATOR\_BEAN\_NAME); definition.getPropertyValues().add(&quot;exposeProxy&quot;, Boolean.TRUE); } } 解析aop:pointcut标签回到ConfigBeanDefinitionParser的Parser方法，他会调用parsePointcut方法解析aop:pointcut标签。 private AbstractBeanDefinition parsePointcut(Element pointcutElement, ParserContext parserContext) { // 获取id属性值 String id = pointcutElement.getAttribute(“id”); // 获取expression属性值 String expression = pointcutElement.getAttribute(“expression”); AbstractBeanDefinition pointcutDefinition = null; try { this.parseState.push(new PointcutEntry(id)); //根据切点表达式来创建一个Pointcut对象的BeanDefinition pointcutDefinition = createPointcutDefinition(expression); pointcutDefinition.setSource(parserContext.extractSource(pointcutElement)); String pointcutBeanName = id; if (StringUtils.hasText(pointcutBeanName)) { //id属性值不为空时，使用id值为Pointcut的bean名称然后注册到容器中 parserContext.getRegistry().registerBeanDefinition(pointcutBeanName, pointcutDefinition); } else { //id属性值为空时，使用bean名称生成器来为Pointcut创建bean名称然后注册到容器中 pointcutBeanName = parserContext.getReaderContext().registerWithGeneratedName(pointcutDefinition); } parserContext.registerComponent( new PointcutComponentDefinition(pointcutBeanName, pointcutDefinition, expression)); } finally { this.parseState.pop(); } return pointcutDefinition; } 我们看一下createPointcutDefinition方法创建了什么？ protected AbstractBeanDefinition createPointcutDefinition(String expression) { RootBeanDefinition beanDefinition = new RootBeanDefinition(AspectJExpressionPointcut.class); //创建AspectJExpressionPointcut对象，域为SCOPE_PROTOTYPE beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE); beanDefinition.setSynthetic(true); beanDefinition.getPropertyValues().add(“expression”, expression); return beanDefinition; } 从上面可以看到他创建了一个AspectJExpressionPointcut对象，域为SCOPE_PROTOTYPE。 解析aop:advisor标签继续回到ConfigBeanDefinitionParser类的parse方法，看他如何解析aop:advisor标签 private void parseAdvisor(Element advisorElement, ParserContext parserContext) { //创建一个Advisor对象对应的BeanDefintion对象 AbstractBeanDefinition advisorDef = createAdvisorBeanDefinition(advisorElement, parserContext); //获取id属性值 String id = advisorElement.getAttribute(ID); try { this.parseState.push(new AdvisorEntry(id)); String advisorBeanName = id; if (StringUtils.hasText(advisorBeanName)) { //id属性值不为空时，使用id值为Advisor的bean名称，并注册到容器中 parserContext.getRegistry().registerBeanDefinition(advisorBeanName, advisorDef); } else { //id属性值为空时，使用bean名称生成器来为Advisor创建bean名称，并注册到容器中 advisorBeanName = parserContext.getReaderContext().registerWithGeneratedName(advisorDef); } //获取Advisor的Pointcut //解析pointcut和poincut-ref属性 Object pointcut = parsePointcutProperty(advisorElement, parserContext); if (pointcut instanceof BeanDefinition) { //获取的是一个根据pointcut属性所指定的切点表达式来创建的的一个Poincut bean advisorDef.getPropertyValues().add(&quot;pointcut&quot;, pointcut); parserContext.registerComponent( new AdvisorComponentDefinition(advisorBeanName, advisorDef, (BeanDefinition) pointcut)); } else if (pointcut instanceof String) { //获取的是pointcut-ref属性值指向的一个Pointcut bean。 advisorDef.getPropertyValues().add(&quot;pointcut&quot;, new RuntimeBeanReference((String) pointcut)); parserContext.registerComponent( new AdvisorComponentDefinition(advisorBeanName, advisorDef)); } } finally { this.parseState.pop(); } } 其实这个parseAdvisor方法就干两件事： 一：通过调用createAdvisorBeanDefinition方法创建并注册了Advisor对象对应的BeanDefintion对象。 二：通过调用parsePointcutProperty方法解析通过pointcut或者pointcut-ref属性获取Advisor的Pointcut createAdvisorBeanDefinition方法 private AbstractBeanDefinition createAdvisorBeanDefinition(Element advisorElement, ParserContext parserContext) { // 指定向容器中注入DefaultBeanFactoryPointcutAdvisor对象作为Advisor RootBeanDefinition advisorDefinition = new RootBeanDefinition(DefaultBeanFactoryPointcutAdvisor.class); advisorDefinition.setSource(parserContext.extractSource(advisorElement)); // 指定Advisor的Advice对象 // 获取advice-ref属性值 String adviceRef = advisorElement.getAttribute(&quot;advice-ref&quot;); if (!StringUtils.hasText(adviceRef)) { parserContext.getReaderContext().error( &quot;&apos;advice-ref&apos; attribute contains empty value.&quot;, advisorElement, this.parseState.snapshot()); } else { advisorDefinition.getPropertyValues().add( &quot;adviceBeanName&quot;, new RuntimeBeanNameReference(adviceRef)); } // 获取order值，用于指定Advise的执行顺序 if (advisorElement.hasAttribute(&quot;order&quot;)) { advisorDefinition.getPropertyValues().add( &quot;order&quot;, advisorElement.getAttribute(&quot;order&quot;)); } return advisorDefinition; } 可以从上面的代码看到createAdvisorBeanDefinition方法不仅创建了Advisor有关的BeanDefinitiion对象，还获取了order和adice-ref属性来设置Advisor的相应属性。 parsePointcutProperty方法private Object parsePointcutProperty(Element element, ParserContext parserContext) { // poincut和pointcut-ref属性不能同时定义 if (element.hasAttribute(“pointcut”) &amp;&amp; element.hasAttribute(“pointcut-ref”)) { parserContext.getReaderContext().error( “Cannot define both ‘pointcut’ and ‘pointcut-ref’ on tag.”, element, this.parseState.snapshot()); return null; } else if (element.hasAttribute(“pointcut”)) { String expression = element.getAttribute(“pointcut”); // 根据切点表达式来创建一个Pointcut的BeanDefinition对象 AbstractBeanDefinition pointcutDefinition = createPointcutDefinition(expression); pointcutDefinition.setSource(parserContext.extractSource(element)); return pointcutDefinition; } else if (element.hasAttribute(“pointcut-ref”)) { // 获取pointcut-ref属性值并返回 String pointcutRef = element.getAttribute(“pointcut-ref”); if (!StringUtils.hasText(pointcutRef)) { parserContext.getReaderContext().error( “‘pointcut-ref’ attribute contains empty value.”, element, this.parseState.snapshot()); return null; } return pointcutRef; } else { parserContext.getReaderContext().error( “Must define one of ‘pointcut’ or ‘pointcut-ref’ on tag.”, element, this.parseState.snapshot()); return null; } } aop:advisor有id、advice-ref、order、pointcut和pointcut-ref共5个属性，其中前三个属性只需要简单获取属性值就可以了，而这段代码的作用就是用来解析pointcut和pointcut-ref属性。 解析aop:aspect标签ConfigBeanDefinitionParser解析器调用它的parseAspect方法解析aop:aspect标签 private void parseAspect(Element aspectElement, ParserContext parserContext) { // 获取id属性值 String aspectId = aspectElement.getAttribute(“id”); // 获取ref属性值 String aspectName = aspectElement.getAttribute(“ref”); try { this.parseState.push(new AspectEntry(aspectId, aspectName)); List&lt;BeanDefinition&gt; beanDefinitions = new ArrayList&lt;BeanDefinition&gt;(); List&lt;BeanReference&gt; beanReferences = new ArrayList&lt;BeanReference&gt;(); List&lt;Element&gt; declareParents = DomUtils.getChildElementsByTagName(aspectElement, &quot;declare-parents&quot;); // 遍历并解析&lt;aop:declare-parents&gt;标签 // 定义有METHOD_INDEX=0 for (int i = METHOD_INDEX; i &lt; declareParents.size(); i++) { Element declareParentsElement = declareParents.get(i); // 解析&lt;aop:declare-parents&gt;标签 beanDefinitions.add(parseDeclareParents(declareParentsElement, parserContext)); } // 遍历并解析before、after、after-returning、after-throwing和around标签 NodeList nodeList = aspectElement.getChildNodes(); boolean adviceFoundAlready = false; for (int i = 0; i &lt; nodeList.getLength(); i++) { Node node = nodeList.item(i); // 判断当前 if (isAdviceNode(node, parserContext)) { if (!adviceFoundAlready) { adviceFoundAlready = true; if (!StringUtils.hasText(aspectName)) { parserContext.getReaderContext().error( &quot;&lt;aspect&gt; tag needs aspect bean reference via &apos;ref&apos; attribute when declaring advices.&quot;, aspectElement, this.parseState.snapshot()); return; } beanReferences.add(new RuntimeBeanReference(aspectName)); } // 解析adice相关的标签，并创建和注册相应的BeanDefinition对象 AbstractBeanDefinition advisorDefinition = parseAdvice( aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences); beanDefinitions.add(advisorDefinition); } } AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition( aspectElement, aspectId, beanDefinitions, beanReferences, parserContext); parserContext.pushContainingComponent(aspectComponentDefinition); // 遍历并解析&lt;aop:pointcut&gt;标签 List&lt;Element&gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT); for (Element pointcutElement : pointcuts) { parsePointcut(pointcutElement, parserContext); } parserContext.popAndRegisterContainingComponent(); } finally { this.parseState.pop(); } } parseAspect方法解析aspect标签下的pointcut、declare-parents和5个advice标签，其中pointcut标签的解析已经在前面看过了，这里我们只需要看后面两种标签的解析。 （1）解析aop:declare-parents标签是会调用parseDeclareParents方法 private AbstractBeanDefinition parseDeclareParents(Element declareParentsElement, ParserContext parserContext) { // 使用BeanDefinitionBuilder对象来构造一个BeanDefinition对象 BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(DeclareParentsAdvisor.class); builder.addConstructorArgValue(declareParentsElement.getAttribute(“implement-interface”)); builder.addConstructorArgValue(declareParentsElement.getAttribute(“types-matching”)); String defaultImpl = declareParentsElement.getAttribute(&quot;default-impl&quot;); String delegateRef = declareParentsElement.getAttribute(&quot;delegate-ref&quot;); // default-impl和delegate-ref不能同时定义 if (StringUtils.hasText(defaultImpl) &amp;&amp; !StringUtils.hasText(delegateRef)) { builder.addConstructorArgValue(defaultImpl); } else if (StringUtils.hasText(delegateRef) &amp;&amp; !StringUtils.hasText(defaultImpl)) { builder.addConstructorArgReference(delegateRef); } else { parserContext.getReaderContext().error( &quot;Exactly one of the &quot; + DEFAULT\_IMPL + &quot; or &quot; + DELEGATE\_REF + &quot; attributes must be specified&quot;, declareParentsElement, this.parseState.snapshot()); } AbstractBeanDefinition definition = builder.getBeanDefinition(); definition.setSource(parserContext.extractSource(declareParentsElement)); // 向容器注册BeanDefinitiion对象 parserContext.getReaderContext().registerWithGeneratedName(definition); return definition; } parseDeclareParents方法作用是向容器注册一个DeclareParentsAdvisor对象。 （2）解析advice标签。spring提供了aop:before、aop:after、aop:after-returning、aop:after-throwing、aop:around5个advice标签，parseAspect调用parseAdvice方法来处理这些标签。 private AbstractBeanDefinition parseAdvice( String aspectName, int order, Element aspectElement, Element adviceElement, ParserContext parserContext, List beanDefinitions, List beanReferences) { try { this.parseState.push(new AdviceEntry(parserContext.getDelegate().getLocalName(adviceElement))); // 创建一个方法工厂bean RootBeanDefinition methodDefinition = new RootBeanDefinition(MethodLocatingFactoryBean.class); methodDefinition.getPropertyValues().add(&quot;targetBeanName&quot;, aspectName); methodDefinition.getPropertyValues().add(&quot;methodName&quot;, adviceElement.getAttribute(&quot;method&quot;)); methodDefinition.setSynthetic(true); // 创建一个用于获取aspect实例的工厂 RootBeanDefinition aspectFactoryDef = new RootBeanDefinition(SimpleBeanFactoryAwareAspectInstanceFactory.class); aspectFactoryDef.getPropertyValues().add(&quot;aspectBeanName&quot;, aspectName); aspectFactoryDef.setSynthetic(true); // 创建Advice AbstractBeanDefinition adviceDef = createAdviceDefinition( adviceElement, parserContext, aspectName, order, methodDefinition, aspectFactoryDef, beanDefinitions, beanReferences); // 配置Advicor RootBeanDefinition advisorDefinition = new RootBeanDefinition(AspectJPointcutAdvisor.class); advisorDefinition.setSource(parserContext.extractSource(adviceElement)); advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef); if (aspectElement.hasAttribute(&quot;order&quot;)) { advisorDefinition.getPropertyValues().add( &quot;order&quot;, aspectElement.getAttribute(&quot;order&quot;)); } // 向容器中注册Advisor parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition); return advisorDefinition; } finally { this.parseState.pop(); } } 1，创建一个用于获取指定aspect实例方法的MethodLocatingFactoryBean对应的BeanDefinition。 2，创建一个用于获取指定aspect实例的SimpleBeanFactoryAwareAspectInstanceFactory对应的BeanDefinition。 3，调用ConfigBeanDefinitionParser解析器的createAdviceDefinition方法创建Advice的BeanDefinition，并注册这个BeanDefinition。 我们看一下是如何创建创建Advice的BeanDefinition private AbstractBeanDefinition createAdviceDefinition( Element adviceElement, ParserContext parserContext, String aspectName, int order, RootBeanDefinition methodDef, RootBeanDefinition aspectFactoryDef, List beanDefinitions, List beanReferences) { RootBeanDefinition adviceDefinition = new RootBeanDefinition(getAdviceClass(adviceElement, parserContext)); adviceDefinition.setSource(parserContext.extractSource(adviceElement)); adviceDefinition.getPropertyValues().add(&quot;aspectName&quot;, aspectName); adviceDefinition.getPropertyValues().add(&quot;declarationOrder&quot;, order); if (adviceElement.hasAttribute(&quot;returning&quot;)) { adviceDefinition.getPropertyValues().add( &quot;returningName&quot;, adviceElement.getAttribute(&quot;returning&quot;)); } if (adviceElement.hasAttribute(&quot;throwing&quot;)) { adviceDefinition.getPropertyValues().add( &quot;throwingName&quot;, adviceElement.getAttribute(&quot;throwing&quot;)); } if (adviceElement.hasAttribute(&quot;arg-names&quot;)) { adviceDefinition.getPropertyValues().add( &quot;argumentNames&quot;, adviceElement.getAttribute(&quot;arg-names&quot;)); } ConstructorArgumentValues cav = adviceDefinition.getConstructorArgumentValues(); // 定义有METHOD_INDEX=0 cav.addIndexedArgumentValue(METHOD_INDEX, methodDef); // 解析poincut和pointcut-ref属性 // 定义有POINTCUT_INDEX = 1 Object pointcut = parsePointcutProperty(adviceElement, parserContext); if (pointcut instanceof BeanDefinition) { cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcut); beanDefinitions.add((BeanDefinition) pointcut); } else if (pointcut instanceof String) { RuntimeBeanReference pointcutRef = new RuntimeBeanReference((String) pointcut); cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcutRef); beanReferences.add(pointcutRef); } // 定义有ASPECT\_INSTANCE\_FACTORY_INDEX = 2 cav.addIndexedArgumentValue(ASPECT\_INSTANCE\_FACTORY_INDEX, aspectFactoryDef); return adviceDefinition; } createAdviceDefinition方法主要是解析adive标签上的属性值。不过在处理属性之前，还需要判断标签类型是5中advice标签中的哪种，下面是getAdviceClass方法的源码。 private Class&lt;?&gt; getAdviceClass(Element adviceElement, ParserContext parserContext) { String elementName = parserContext.getDelegate().getLocalName(adviceElement); if (“before”.equals(elementName)) { return AspectJMethodBeforeAdvice.class; } else if (“after”.equals(elementName)) { return AspectJAfterAdvice.class; } else if (“after-returning”.equals(elementName)) { return AspectJAfterReturningAdvice.class; } else if (“after-throwing”.equals(elementName)) { return AspectJAfterThrowingAdvice.class; } else if (“around”.equals(elementName)) { return AspectJAroundAdvice.class; } else { throw new IllegalArgumentException(“Unknown advice kind [“ + elementName + “].”); } } 至此，我们就完成了探索spring遇到aop命名空间下的config标签时会创建哪些类型对应的BeanDefiniton，所有的Adivce也注册到了容器中。IOC容器也初始化完成了。]]></content>
      <categories>
        <category>Spring源码分析-AOP（三）XML解析</category>
      </categories>
      <tags>
        <tag>Spring源码分析-AOP（三）XML解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-AOP（二）入门]]></title>
    <url>%2F2017%2F04%2F24%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-aop-ef-bc-88-e4-ba-8c-ef-bc-89-e5-85-a5-e9-97-a8%2F</url>
    <content type="text"><![CDATA[Spring AOP AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 Spring AOP 架构 先是生成代理对象，然后是拦截器的作用，最后是编织的具体实现。这是AOP实现的三个步骤，当然Spring AOP也是一样。 而从Spring AOP整体架构上看**，其核心都是建立在代理上的。当我们建立增强实例时，我们必须先使用 ProxyFactory 类加入我们需要织入该类的所有增强，然后为该类创建代理。一般而言，AOP实现代理的方法有三种，而 Spring 内部用到了其中的两种方法：动态代理和静态代理，而动态代理又分为JDK动态代理和CGLIB代理**。下面是 Spring AOP 生成代理的原理图： 而特别需要注意的是，在 Spring AOP 中，一个 Advisor（通知者，也翻作 通知器或者增强器）就是一个切面，他的主要作用是整合切面增强设计（Advice）和切入点设计（Pointcut）。Advisor有两个子接口：IntroductionAdvisor 和 PointcutAdvisor，基本所有切入点控制的 Advisor 都是由 PointcutAdvisor 实现的。而下面的是Spring AOP的整体架构图 乍一看，非常的复杂，但如果结合上面的Spring AOP生成代理的原理图一起看，也就那么回事，只是丰富的许多属性了，我们会慢慢介绍的。 准备一个代理对象 public class ProxyClass { public void sayProxy(){ System.out.println(“sayProxy……”); }} 一个通知类 public class AdviceClass { public void before(){ System.out.println(“sayBefore……”); } public void after(){ System.out.println(“sayAfter……”); }} spring的配置文件spring.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; aop:config &lt;aop:pointcut expression=”execution( aop..*(..))” id=”pt”/&gt; &lt;aop:aspect ref=”advice”&gt; &lt;aop:before method=”before” pointcut-ref=”pt”/&gt; &lt;aop:after method=”after” pointcut-ref=”pt”/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试类 public class Aop_Test { @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(“spring.xml”); ProxyClass bean = context.getBean(“proxy”, ProxyClass.class); bean.sayProxy(); }} 上文说道，aop:config标签是在AopNamespaceHandler的init方法中解析。 @Override public void init() { // In 2.0 XSD as well as in 2.1 XSD. registerBeanDefinitionParser(“config”, new ConfigBeanDefinitionParser()); registerBeanDefinitionParser(“aspectj-autoproxy”, new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(“scoped-proxy”, new ScopedProxyBeanDefinitionDecorator()); // Only in 2.0 XSD: moved to context namespace as of 2.1 registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); } 由此，我们知道只要配置文件中的“aop:config”的注解时就会使用解析器对 ConfigBeanDefinitionParser进行解析。上文也提到过得到NamespaceHandler方法后会调用parse方法。其实在解析aop:config标签时parse方法中得的就是ConfigBeanDefinitionParser的解析器，然后调用了它的parse方法。 private static final String ASPECT = &quot;aspect&quot;; private static final String EXPRESSION = &quot;expression&quot;; private static final String ID = &quot;id&quot;; private static final String POINTCUT = &quot;pointcut&quot;; private static final String ADVICE\_BEAN\_NAME = &quot;adviceBeanName&quot;; private static final String ADVISOR = &quot;advisor&quot;; private static final String ADVICE_REF = &quot;advice-ref&quot;; private static final String POINTCUT_REF = &quot;pointcut-ref&quot;; private static final String REF = &quot;ref&quot;; private static final String BEFORE = &quot;before&quot;; private static final String DECLARE_PARENTS = &quot;declare-parents&quot;; private static final String TYPE_PATTERN = &quot;types-matching&quot;; private static final String DEFAULT_IMPL = &quot;default-impl&quot;; private static final String DELEGATE_REF = &quot;delegate-ref&quot;; private static final String IMPLEMENT_INTERFACE = &quot;implement-interface&quot;; private static final String AFTER = &quot;after&quot;; private static final String AFTER\_RETURNING\_ELEMENT = &quot;after-returning&quot;; private static final String AFTER\_THROWING\_ELEMENT = &quot;after-throwing&quot;; private static final String AROUND = &quot;around&quot;; private static final String RETURNING = &quot;returning&quot;; private static final String RETURNING_PROPERTY = &quot;returningName&quot;; private static final String THROWING = &quot;throwing&quot;; private static final String THROWING_PROPERTY = &quot;throwingName&quot;; private static final String ARG_NAMES = &quot;arg-names&quot;; private static final String ARG\_NAMES\_PROPERTY = &quot;argumentNames&quot;; private static final String ASPECT\_NAME\_PROPERTY = &quot;aspectName&quot;; private static final String DECLARATION\_ORDER\_PROPERTY = &quot;declarationOrder&quot;; private static final String ORDER_PROPERTY = &quot;order&quot;; private static final int METHOD_INDEX = 0; private static final int POINTCUT_INDEX = 1; private static final int ASPECT\_INSTANCE\_FACTORY_INDEX = 2; private ParseState parseState = new ParseState(); @Override public BeanDefinition parse(Element element, ParserContext parserContext) { CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element)); parserContext.pushContainingComponent(compositeDef); //1 . 注册一个AspectJAwareAdvisorAutoProxyCreator类型的bean configureAutoProxyCreator(parserContext, element); //2\. 解析主标签下面的advisor标签，并且注册advisor. List&lt;Element&gt; childElts = DomUtils.getChildElements(element); for (Element elt: childElts) { String localName = parserContext.getDelegate().getLocalName(elt); if (POINTCUT.equals(localName)) { parsePointcut(elt, parserContext); } else if (ADVISOR.equals(localName)) { parseAdvisor(elt, parserContext); } else if (ASPECT.equals(localName)) { parseAspect(elt, parserContext); } } parserContext.popAndRegisterContainingComponent(); return null; } 不难看出，其实上面就看你两件事，第一件事注册一个AspectJAwareAdvisorAutoProxyCreator类型的bean，第二件事就是解析主标签下面的advisor标签，并且注册advisor。 下面看一下是如何注册一个AspectJAwareAdvisorAutoProxyCreator，实现在AopNamespaceUtils private void configureAutoProxyCreator(ParserContext parserContext, Element element) { AopNamespaceUtils.registerAspectJAutoProxyCreatorIfNecessary(parserContext, element); } public static void registerAspectJAutoProxyCreatorIfNecessary( ParserContext parserContext, Element sourceElement) { BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAutoProxyCreatorIfNecessary( parserContext.getRegistry(), parserContext.extractSource(sourceElement)); // 解析&lt;aop:config&gt;标签的proxy-target-class和expose-proxy属性 useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement); registerComponentIfNecessary(beanDefinition, parserContext); } public static BeanDefinition registerAspectJAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object source) { //这里传递了一个类型为AspectJAwareAdvisorAutoProxyCreator的class return registerOrEscalateApcAsRequired(AspectJAwareAdvisorAutoProxyCreator.class, registry, source); } public static final String AUTO\_PROXY\_CREATOR\_BEAN\_NAME = &quot;org.springframework.aop.config.internalAutoProxyCreator&quot;; private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) { Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;); // 定义有AUTO\_PROXY\_CREATOR\_BEAN\_NAME=&quot;org.springframework.aop.config.internalAutoProxyCreator&quot; if (registry.containsBeanDefinition(AUTO\_PROXY\_CREATOR\_BEAN\_NAME)) { // 如果容器中已经存在自动代理构建器，则比较两个构建器的优先级 BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO\_PROXY\_CREATOR\_BEAN\_NAME); if (!cls.getName().equals(apcDefinition.getBeanClassName())) { int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName()); int requiredPriority = findPriorityForClass(cls); // 保存优先级高的构建器 if (currentPriority &lt; requiredPriority) { apcDefinition.setBeanClassName(cls.getName()); } } return null; } // 如果容器中还没有自动代理构建器则创建构建器相应的BeanDefinition对象 RootBeanDefinition beanDefinition = new RootBeanDefinition(cls); beanDefinition.setSource(source); beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); // 向容器中注册代理构建器的BeanDefinition对象 registry.registerBeanDefinition(AUTO\_PROXY\_CREATOR\_BEAN\_NAME, beanDefinition); return beanDefinition; } 这里就是注册了一个AspectJAwareAdvisorAutoProxyCreator类，需要注意的是这里的cls是调用方法的时候传递过来的，类型是AspectJAwareAdvisorAutoProxyCreator。那么AspectJAwareAdvisorAutoProxyCreator又有什么特殊的地方呢？通过查看继承关系，发现在他父类的父类AbstractAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor接口，而这个接口继承了InstantiationAwareBeanPostProcessor。这个InstantiationAwareBeanPostProcessor是BeanPostProcessor的一个子类，在bean初始化的时候调用postProcessBeforeInstantiation方法。]]></content>
      <categories>
        <category>Spring源码分析-AOP（二）入门</category>
      </categories>
      <tags>
        <tag>Spring源码分析-AOP（二）入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-AOP（一）预备知识]]></title>
    <url>%2F2017%2F04%2F24%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-aop-ef-bc-88-e4-b8-80-ef-bc-89-e9-a2-84-e5-a4-87-e7-9f-a5-e8-af-86%2F</url>
    <content type="text"><![CDATA[了解IOC容器初始化过程的同学一定知道，ico在初始化的时候会解析XML然后转换成Bean持有信息类BeanDefinition。阅读过IOC源码的同学也一定熟悉下面的代码，如果没有阅读过，不妨看一下我写的IOC源码系列。 在DefaultBeanDefinitionDocumentReader类的doRegisterBeanDefinitions方法（这个方法就是解析为BeanDefinition的入口） protected void doRegisterBeanDefinitions(Element root) { // Any nested elements will cause recursion in this method. In // order to propagate and preserve default-* attributes correctly, // keep track of the current (parent) delegate, which may be null. Create // the new (child) delegate with a reference to the parent for fallback purposes, // then ultimately reset this.delegate back to its original (parent) reference. // this behavior emulates a stack of delegates without actually necessitating one. BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String\[\] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI\_VALUE\_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isInfoEnabled()) { logger.info(&quot;Skipped XML bean definition file due to specified profiles \[&quot; + profileSpec + &quot;\] not matching: &quot; + getReaderContext().getResource()); } return; } } } preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent; } spring在这里提供了xml配置文件解析的两个扩展接口：preProcessXml,postProcessXml. 用户可以根据自身需求扩展这两个接口。下面就关注一下上面代码里面加载bean的核心方法：parseBeanDefinition protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { parseDefaultElement(ele, delegate); } else { delegate.parseCustomElement(ele); } } } } else { delegate.parseCustomElement(root); } } 从上面代码可以看出，xml配置文件里面的标签里面的闭合标签被解析成一个个Node。如果是默认的NameSpace标签 则分为import,alias,bean等标签进行解析并注册相应的bean，否则这调用parseCustomElement方法。 public BeanDefinition parseCustomElement(Element ele) { return parseCustomElement(ele, null); } public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) { String namespaceUri = getNamespaceURI(ele); NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) { error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace \[&quot; + namespaceUri + &quot;\]&quot;, ele); return null; } return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); } 可以看到得到NamespaceHandler然后会调用parse方法。我们看一下是如何得到NamespaceHandler！点开resolve方法，NamespaceHandlerResolver只是个接口，其实现类是在DefaultNamespaceHandlerResolver。 public NamespaceHandler resolve(String namespaceUri) { Map&lt;String, Object&gt; handlerMappings = getHandlerMappings(); Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) { return null; } else if (handlerOrClassName instanceof NamespaceHandler) { return (NamespaceHandler) handlerOrClassName; } else { String className = (String) handlerOrClassName; try { Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException(“Class [“ + className + “] for namespace [“ + namespaceUri + “] does not implement the [“ + NamespaceHandler.class.getName() + “] interface”); } NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); namespaceHandler.init(); handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; } catch (ClassNotFoundException ex) { throw new FatalBeanException(“NamespaceHandler class [“ + className + “] for namespace [“ + namespaceUri + “] not found”, ex); } catch (LinkageError err) { throw new FatalBeanException(“Invalid NamespaceHandler class [“ + className + “] for namespace [“ + namespaceUri + “]: problem with handler class file or dependent class”, err); } } } spring为简化AOP在xml文件中的定义而创建了一个http://www.springframework.org/schema/aop命名空间，这里我简称为aop命名空间。spring在解析xml配置文件内容的过程中遇到非默认命名空间时，会查找系统中所有META-INF目录下的spring.handlers文件中与命名空间对应的处理器，我们可以在spring-aop-x.x.x-RELEASE.jar包的META-INF目录中的spring.handlers文件可以找到找到aop命名空间的处理器。 上面可以看到，先得到HandlerMapping，然后根据namespaceUri取到对应的handlerOrClassName。在反射出来得到NamespaceHandler。然后调用了init方法。譬如:这里我们就解析aop:config &lt;/aop:config&gt;那么就是根据namespaceUri取出AopNamespaceHandler的全限定类名。然后反射出一个AopNamespaceHandler对象，再调用AopNamespaceHandler的init方法等。 我们回到parseCustomElement继续向下看，此时我们得到了NamespaceHandler，然后调用parse方法。 @Override public BeanDefinition parse(Element element, ParserContext parserContext) { return findParserForElement(element, parserContext).parse(element, parserContext); } /\*\* \* Locates the {@link BeanDefinitionParser} from the register implementations using \* the local name of the supplied {@link Element}. */ private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) { String localName = parserContext.getDelegate().getLocalName(element); BeanDefinitionParser parser = this.parsers.get(localName); if (parser == null) { parserContext.getReaderContext().fatal( &quot;Cannot locate BeanDefinitionParser for element \[&quot; + localName + &quot;\]&quot;, element); } return parser; } 通过findParserForElement方法得到了一个BeanDefinitionParser，然后再调用该类的parse方法。 上面的都是aop知识的铺垫，下面的文章会用到这些。]]></content>
      <categories>
        <category>Spring源码分析-AOP（一）预备知识</category>
      </categories>
      <tags>
        <tag>Spring源码分析-AOP（一）预备知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringIOC源码分析系列]]></title>
    <url>%2F2017%2F04%2F23%2Fspringioc-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-e7-b3-bb-e5-88-97%2F</url>
    <content type="text"><![CDATA[Spring的出现是为了取代EJB的臃肿、低效、脱离现实缺点，Spring致力于J2EE应用的各层的解决方案，是企业应用开发的“一站式”选择，贯穿表现层、业务层及持久层。Spring并不想取代那些已有的框架，而是与它们无缝地整合。Spring是分层的JavaSE/EE应用一站式的轻量级开源框架，以Ioc（Inverse of control）控制反转和Aop（Aspect Oriented Programming）面向切面编程为核心 。 spring的架构图 本片系列文章参考主要spring技术内幕一书，还有网络上的一些博客，这里就不一一列举了。本来我是写在word中，然后搬到了blog中。适合于想研究IOC源码或想深入学习一下IOC的话，可以参考本系列文章。如果有哪里不对，欢迎指出感激不尽。 本系列的文章都是基于Spring4.3.3.RELEASE版本的 文章阅读顺序：Spring源码分析-IOC（一）容器 Spring源码分析-IOC（二）入门 Spring源码分析-IOC（三）容器初始化 Spring源码分析-IOC（四）BeanDefinition解析和注册 Spring源码分析-IOC（五）依赖注入 Spring源码分析-IOC（六）IOC容器小结]]></content>
      <categories>
        <category>SpringIOC源码分析系列</category>
      </categories>
      <tags>
        <tag>SpringIOC源码分析系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-IOC（六）IOC容器小结]]></title>
    <url>%2F2017%2F04%2F23%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-ioc-ef-bc-88-e5-85-ad-ef-bc-89ioc-e5-ae-b9-e5-99-a8-e5-b0-8f-e7-bb-93%2F</url>
    <content type="text"><![CDATA[如果把Ioc容器比喻成一个人的话，Bean对象们就构成了他的骨架，依赖注入就是他的血肉，各种组件和支持则汇成了他的筋脉和皮肤，而各种特性则是他的灵魂。各种特性真正的使**Spring Ioc有别于其他Ioc框架，也成就了应用开发的丰富多彩，Spring Ioc 作为一个产品，可以说，他的各种特性才是它真正的价值所在。** Spring Ioc的特性非常的多，了解了Spring Ioc容器整个运行原理后，按照相同思路分析这些特性相信也不是一件难事。如果读者感兴趣的话，也可以按照相同的思路进行研究。这里仅仅举个例子： 例子：**Bean**的完整生命周期 Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。 Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类： 1、Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中的init-method和destroy-method指定的方法 2、Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法 3、容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。 4、工厂后处理器接口方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。 总结：Spring Ioc容器的核心是BeanFactory和BeanDefinition。分别对应对象工厂和依赖配置的概念。虽然我们通常使用的是ApplicationContext的实现类，但ApplicationContext只是封装和扩展了BeanFactory的功能。XML的配置形式只是Spring依赖注入的一种常用形式而已，而AnnotationConfigApplicationContext配合Annotation注解和泛型，早已经提供了更简易的配置方式，AnnotationConfigApplicationContext和AnnotationConfigWebApplicationContext则是实现无XML配置的核心接口，但无论你使用任何配置，最后都会映射到BeanDefinition。 其次，这里特别要注意的还是BeanDefinition， Bean在XML文件里面的展现形式是&lt;bean id=&quot;...&quot;&gt;...&lt;/bean&gt;，当这个节点被加载到内存中，就被抽象为BeanDefinition了，在XML Bean节点中的那些关键字，在BeanDefinition中都有相对应的成员变量。如何把一个XML节点转换成BeanDefinition，这个工作自然是由BeanDefinitionReader来完成的。Spring通过定义BeanDefinition来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系。BeanDefinition抽象了我们对Bean的定义，是让容器起作用的主要数据类型。我们知道在计算机世界里，所有的功能都是建立在通过数据对现实进行抽象的基础上的。Ioc容器是用BeanDefinition来管理对象依赖关系的，对Ioc容器而言，BeanDefinition就是对控制反转模式中管理的对象依赖关系的数据抽象，也是容器实现控制反转的核心数据结构，有了他们容器才能发挥作用。 IOC容器启动执行流程： ioc容器启动其实就干了5件事 1，启动容器refresh() 2，完成resource的定位 3，使用DefaultBeanDefinitionDocumentReader读入xml文件，并将xml转换为BeanDefinition 4，使用BeanDefinitionParserDelegate进行解析 5，使用DefaultListableBeanFactory 进行注册 IOC依赖注入流程图 依赖注入也干这几件事 1，得到bean 2，在父子容器中寻找bean，没有找到就创建bean 3，默认使用SimpleInstantiationStrategy类通过cglib技术生成对象 4，通过BeanDefinitionValueResolver 类来解析依赖属性 5，使用AbstractPropertyAccessor 来注入依赖属性 最后，**其实IoC从原理上说是非常简单的，就是把xml文件解析出来，然后放到内存的map里，最后在内置容器里管理bean。但是看IoC的源码，却发现其非常庞大，看着非常吃力。这是因为spring加入了很多特性和为扩展性预留很多的接口，这些特性和扩展，造就了它无与伦比的功能以及未来无限的可能性，可以说正是他们将技术的美学以最简单的方法呈现在了人们面前，当然这也导致了他的复杂性**。]]></content>
      <categories>
        <category>Spring源码分析-IOC（六）IOC容器小结</category>
      </categories>
      <tags>
        <tag>Spring源码分析-IOC（六）IOC容器小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-IOC（五）依赖注入]]></title>
    <url>%2F2017%2F04%2F22%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-ioc-ef-bc-88-e4-ba-94-ef-bc-89-e4-be-9d-e8-b5-96-e6-b3-a8-e5-85-a5%2F</url>
    <content type="text"><![CDATA[上篇文章看完的同学，估计已经了解了ioc容器是如何初始化并载入了用户定义的Bean信息。那么依赖注入是什么时候触发的？其实依赖注入是当用户getBean的时候触发依赖注入，当然也有例外，就是当Bean配置了lazy-init的时候，依赖注入在ioc容器初始化的时候注入。可以从测试类的getBean出发去看看具体是的实现。 依赖注入//调用了AbstractBeanFactory的getBean方法@Override public T getBean(String name, Class requiredType) throws BeansException { return doGetBean(name, requiredType, null, false); }@SuppressWarnings(“unchecked”)// doGetBean方法是实际触发依赖注入的地方 protected T doGetBean( final String name, final Class requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException {//指定名称获取被管理的Bean名称，并且指定名称中对容器的依赖//如果是别名，将别名转变为Bean的名称 final String beanName = transformedBeanName(name); Object bean; //先缓存取得的Bean以及处理创建过的单件模式的Bean //单态模式的Bean只能创建一次. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) { if (logger.isDebugEnabled()) { //如果指定名称的Bean在容器中已经存在，则直接返回 if (isSingletonCurrentlyInCreation(beanName)) { logger.debug(“Returning eagerly cached instance of singleton bean ‘“ + beanName + “‘ that is not fully initialized yet - a consequence of a circular reference”); } else { logger.debug(“Returning cached instance of singleton bean ‘“ + beanName + “‘“); } } //这里完成FactoryBean的相关处理 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { //缓存中如果已经存在创建的单态模式，因为循环而创建失败，则抛出异常 if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } //对容器中的BeanDefinition进行检查，检查能否在当前的BeanFactory中取得Bean. //如果在当前的工厂中取不到，则到父类的BeanFactory中去取//如果在父类中取不到，则到父类的父类中取. BeanFactory parentBeanFactory = getParentBeanFactory();//当前容器的父容器存在，且当前容器中不存在指名的Bean if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) { // //解析Bean的原始名. String nameToLookup = originalBeanName(name); if (args != null) { // //委派给父类容器查找，根据指定的名称和显示参数. return (T) parentBeanFactory.getBean(nameToLookup, args); } else { // //委派给父类容器查找，根据指定的名称和类型. return parentBeanFactory.getBean(nameToLookup, requiredType); } }//创建的Bean是否需要进行验证，一般不需要 if (!typeCheckOnly) { //向容器指定的Bean已被创建 markBeanAsCreated(beanName); } try { //根据Bean的名字获取BeanDefinition final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); //获取当前Bean的所有依赖的名称. String\[\] dependsOn = mbd.getDependsOn(); //如果当前Bean有依赖Bean if (dependsOn != null) { for (String dependsOnBean : dependsOn) { if (isDependent(beanName, dependsOnBean)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, “Circular depends-on relationship between ‘“ + beanName + “‘ and ‘“ + dependsOnBean + “‘“); } //把被依赖的Bean注册给当前依赖的Bean registerDependentBean(dependsOnBean, beanName); //触发递归 getBean(dependsOnBean); } } //创建单态模式的Bean实例对象. if (mbd.isSingleton()) { //使用一个内部匿名类，创建Bean实例对象，并且注册对所依赖的对象 sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() { @Override public Object getObject() throws BeansException { try { //创建一个指定Bean实例对象，如果有父级继承，则合并资对象 return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. //清除显示容器单例模式Bean缓存中的实例对象 destroySingleton(beanName); throw ex; } } }); //获取给定Bean实例对象 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } // 判断是否是原型模式 else if (mbd.isPrototype()) { // It’s a prototype -&gt; create a new instance. //原型模式会每次创建一个新的对象 Object prototypeInstance = null; try { //回调方法，注册原型对象 beforePrototypeCreation(beanName); //创建指定Bean对象实例 prototypeInstance = createBean(beanName, mbd, args); } finally { //回调方法，Bean无法再次创建 afterPrototypeCreation(beanName); } //获取给定Bean的实例对象 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } else { String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); //Bean定义资源中没有配置生命周期范围，则Bean不合法 if (scope == null) { throw new IllegalStateException(&quot;No Scope registered for scope &apos;&quot; + scopeName + &quot;&apos;&quot;); } try { //这里使用一个匿名类，获取一个指定的生命周期范围 Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() { @Override public Object getObject() throws BeansException { beforePrototypeCreation(beanName); try { return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } } }); //获取给定Bean的实例对象 bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new BeanCreationException(beanName, &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; &quot; + &quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, ex); } } } catch (BeansException ex) { cleanupAfterBeanCreationFailure(beanName); throw ex; } } // 对创建的Bean进行类型检查，如果没有问题，就返回这个新建的Bean，这个Bean已经包含了依赖关系. if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) { try { return getTypeConverter().convertIfNecessary(bean, requiredType); } catch (TypeMismatchException ex) { if (logger.isDebugEnabled()) { logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type \[&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;\]&quot;, ex); } throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } } return (T) bean; } 从上面，可以看出doGetBean，是依赖注入的实际入口，他定义了Bean的定义模式，单例模式（Singleton）和原型模（Prototype），而依赖注入触发的前提是BeanDefinition数据已经建立好的前提下。其实对于Ioc容器的使用，Spring提供了许多的参数配置，每一个参数配置实际上代表了一个Ioc实现特性，而这些特性的实现很多都需要在依赖注入的过程中或者对Bean进行生命周期管理的过程中完成。Spring Ioc容器作为一个产品，其真正的价值体现在一系列产品特征上，而这些特征都是以依赖反转模式作为核心，他们为控制反转提供了很多便利，从而实现了完整的Ioc容器。 bean**实例的创建和初始化：**createBeangetBean是依赖注入的起点，之后就会调用createBean，createBean可以生成需要的Bean以及对Bean进行初始化，但对createBean进行跟踪，发现他在AbstractBeanFactory中仅仅是声明，而具体实现是在AbstractAutowireCapableBeanFactory类里。 @Override protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException { if (logger.isDebugEnabled()) { logger.debug(&quot;Creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;); } //判断创建的Bean是否需要实例化，以及这个类是否需要通过类来装载. resolveBeanClass(mbd, beanName); //校验和准备中的方法覆盖. try { mbd.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex); } try { //如果Bean配置了初始化前和后的处理器，则返回一个Bean对象. Object bean = resolveBeforeInstantiation(beanName, mbd); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex); } //创建Bean的入口Object beanInstance = doCreateBean(beanName, mbd, args); if (logger.isDebugEnabled()) { logger.debug(“Finished creating instance of bean ‘“ + beanName + “‘“); } return beanInstance; } //Bean的真正创建位置protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) { /// 这个BearWrapper是用来封装创建出来的Bean对象的. BeanWrapper instanceWrapper = null;// 如果是单态模式，就先把缓存中同名的Bean清除 if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } //创建Bean，由createBeanInstance来完成 if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); // Allow post-processors to modify the merged bean definition. //调用PostProcessor后置处理器 synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; } } // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. //缓存单态模式的Bean对象，以防循环引用 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isDebugEnabled()) { logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName + &quot;&apos; to allow for resolving potential circular references&quot;); } //匿名类，防止循环引用，可尽早的持有引用对象 addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() { @Override public Object getObject() throws BeansException { return getEarlyBeanReference(beanName, mbd, bean); } }); } // Initialize the bean instance. //初始化Bean的地方，依赖注入发生的地方 //exposedObject在初始化完成后，会作为依赖注入完成后的Bean Object exposedObject = bean; try { //将Bean实例对象进行封装，并将Bean定义的配置属性赋值给实例对象 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) { //初始化Bean exposedObject = initializeBean(beanName, exposedObject, mbd); } } catch (Throwable ex) { if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException(mbd.getResourceDescription(), beanName, “Initialization of bean failed”, ex); } } if (earlySingletonExposure) { //获取指定名称的单态模式对象 Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { //判断注册的实例化Bean和正在实例化的Bean是同一个 if (exposedObject == bean) { exposedObject = earlySingletonReference; } //当前Bean依赖其他Bean，并且当发生循环引用时不允许创建新实例 else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) { String\[\] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); //获取当前Bean的所有依赖 for (String dependentBean : dependentBeans) { //对依赖bean进行检查 if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name &apos;&quot; + beanName + &quot;&apos; has been injected into other beans \[&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;\] in its raw version as part of a circular reference, but has eventually been &quot; + &quot;wrapped. This means that said other beans do not use the final version of the &quot; + &quot;bean. This is often the result of over-eager type matching - consider using &quot; + &quot;&apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for example.&quot;); } } } } //注册完成依赖注入的Bean. try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex); } return exposedObject; } 在对doCreateBean的追踪中我们发现Bean的创建方法createBeanInstance与BeanDefinition的载入与解析方法populateBean方法是最为重要的。因为控制反转原理的实现就是在这两个方法中实现的。 生成Bean中的对象：createBeanInstance在createBeanInstance中生成了Bean所包含的Java对象，对象的生成有很多种不同的方法：工厂方法+反射，容器的autowire特性等等，这些生成方法都是由相关BeanDefinition来指定的。 protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) { // Make sure bean class is actually resolved at this point. // 确认需要创建的Bean实例的类可以实例化 Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Bean class isn&apos;t public, and non-public access not allowed: &quot; + beanClass.getName()); } //这里使用工厂方法对Bean进行实例化 if (mbd.getFactoryMethodName() != null) { return instantiateUsingFactoryMethod(beanName, mbd, args); } // Shortcut when re-creating the same bean... //使用容器自动装配方法进行实例化 boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } if (resolved) { if (autowireNecessary) { //配置自动装配属性，使用容器自动实例化 return autowireConstructor(beanName, mbd, null, null); } else { //无参构造方法实例化 return instantiateBean(beanName, mbd); } } // Need to determine the constructor... //使用构造函数进行实例化 Constructor&lt;?&gt;\[\] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { //使用容器自动装配，调用构造方法实例化return autowireConstructor(beanName, mbd, ctors, args); } // No special handling: simply use no-arg constructor. //使用默认构造函数对Bean进行实例化 return instantiateBean(beanName, mbd); } /** * CGLIB是一个常用的字节码生成器的类库，他提供了一系列的API来提供生成和转换Java的字节码功能。 * 在Spring AOP中也使用CGLIB对Java的字节码进行了增强。 */private InstantiationStrategy instantiationStrategy = new CglibSubclassingInstantiationStrategy(); protected InstantiationStrategy getInstantiationStrategy() { return this.instantiationStrategy;} /** * 最常见的实例化过程instantiateBean * 使用默认的实例化策略对Bean进行实例化，默认的实例化策略是 * CglibSubclassingInstantiationStrategy，也就是用CGLIB来对Bean进行实例化 */protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) { try { Object beanInstance; final BeanFactory parent = this; //获取系统的安全管理接口 if (System.getSecurityManager() != null) { beanInstance = AccessController.doPrivileged(new PrivilegedAction() { @Override public Object run() { return getInstantiationStrategy().instantiate(mbd, beanName, parent); } }, getAccessControlContext()); } else { //实例化的对象封装 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); } BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, “Instantiation of bean failed”, ex); } } 我们对CglibSubclassingInstantiationStrategy进行跟踪，发现Spring中的CGLIB生成，是由SimpleInstantiationStrategy.instantiate方法来完成的，所以我们就直接看SimpleInstantiationStrategy.instantiate @Override public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) { // Don’t override the class with CGLIB if no overrides. if (bd.getMethodOverrides().isEmpty()) { /指定构造器或者生成的对象工厂方法来对Bean进行实例化 Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) { constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) { final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) { throw new BeanInstantiationException(clazz, “Specified class is an interface”); } try { if (System.getSecurityManager() != null) { constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() { @Override public Constructor&lt;?&gt; run() throws Exception { return clazz.getDeclaredConstructor((Class[]) null); } }); } else { constructorToUse = clazz.getDeclaredConstructor((Class[]) null); } bd.resolvedConstructorOrFactoryMethod = constructorToUse; } catch (Exception ex) { throw new BeanInstantiationException(clazz, “No default constructor found”, ex); } } } //通过BeanUtils进行实例化，这个BeanUtils的实例化通过Constructor来完成 return BeanUtils.instantiateClass(constructorToUse); } else { // Must generate CGLIB subclass. //使用CGLIB来实例化对象 return instantiateWithMethodInjection(bd, beanName, owner); } } 从上面可以看到SimpleInstantiationStrategy是sprng用来生成Bean对象的默认类，它提供了两种方式一种是BeanUtils，它是使用了jvm的反射机制，另外一种就是cglib。 属性依赖注入实现：**populateBean**Bean对象进行实例化以后。怎么把这些Bean对象之间的依赖关系处理好，以完成整个依赖注入，而这里就涉及到各种Bean对象依赖关系的处理过程了，而这些依赖关系都已经解析到了BeanDefinition。如果要仔细理解这个过程，我们必须从前面提到的populateBean方法入手。 protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) { //这里取得BeanDefinition中的property值 PropertyValues pvs = mbd.getPropertyValues(); //实例对象为NULL if (bw == null) { if (!pvs.isEmpty()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, “Cannot apply property values to null instance”); } else { // Skip property population phase for null instance. //实例对象为NULL，属性值也为空，不需设置，直接返回 return; } } //在设置属性之前调用Bean的PostProcessor后置处理器 boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { continueWithPropertyPopulation = false; break; } } } } if (!continueWithPropertyPopulation) { return; } //开始进行依赖注入过程，先处理autowire的注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE\_BY\_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE\_BY\_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); //根据Bean的名字或者类型自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE\_BY\_NAME) { autowireByName(beanName, mbd, bw, newPvs); } //根据类型自动装配注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE\_BY\_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } //检查日期是否持有用于单态模式Bean关闭时的后置处理器 boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); //Bean实例对象没有依赖，也没有继承 boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY\_CHECK\_NONE); if (hasInstAwareBpps || needsDepCheck) { //从实例对象中提取属性描述符 PropertyDescriptor\[\] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { //使用BeanPostProcessor处理器处理属性值 InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) { return; } } } } if (needsDepCheck) { //对要配置的属性进行依赖检查 checkDependencies(beanName, mbd, filteredPds, pvs); } } //对属性进行依赖注入 applyPropertyValues(beanName, mbd, bw, pvs); } protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) { if (pvs == null || pvs.isEmpty()) { return; } //封装属性值 MutablePropertyValues mpvs = null; List&lt;PropertyValue&gt; original; if (System.getSecurityManager() != null) { if (bw instanceof BeanWrapperImpl) { //设置安全上下文，JDK安全机制 ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext()); } } if (pvs instanceof MutablePropertyValues) { mpvs = (MutablePropertyValues) pvs; //属性值已经转换 if (mpvs.isConverted()) { // Shortcut: use the pre-converted values as-is. try { //为实例化对象设置属性值 bw.setPropertyValues(mpvs); return; } catch (BeansException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex); } } //获取属性值对象的原始类型值 original = mpvs.getPropertyValueList(); } else { original = Arrays.asList(pvs.getPropertyValues()); } //获取用户自定义的类型转换 TypeConverter converter = getCustomTypeConverter(); if (converter == null) { converter = bw; } //创建一个Bean定义属性值解析器，将Bean定义中的属性值解析为Bean实例对象 的实际值 BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter); //这里为解析值创建的一个副本，然后通过副本注入Bean List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;PropertyValue&gt;(original.size()); boolean resolveNecessary = false; //转换属性值 for (PropertyValue pv : original) { if (pv.isConverted()) { deepCopy.add(pv); } else { String propertyName = pv.getName(); //原始的属性值，即转换之前的属性值 Object originalValue = pv.getValue(); //转换属性值，例如将引用转换为IoC容器中实例化对象引用（属性值解析） Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue); Object convertedValue = resolvedValue; boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp; !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName); if (convertible) { //使用用户自定义的类型转换器转换属性值 convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter); } // Possibly store converted value in merged bean definition, // in order to avoid re-conversion for every created bean instance. //存储转换后的属性值，避免每次属性注入时的转换工作 if (resolvedValue == originalValue) { if (convertible) { pv.setConvertedValue(convertedValue); } deepCopy.add(pv); } //属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是 //动态生成的字符串，且属性的原始值不是集合或者数组类型 else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp; !((TypedStringValue) originalValue).isDynamic() &amp;&amp; !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) { pv.setConvertedValue(convertedValue); deepCopy.add(pv); } else { resolveNecessary = true; deepCopy.add(new PropertyValue(pv, convertedValue)); } } } if (mpvs != null &amp;&amp; !resolveNecessary) { mpvs.setConverted(); } // 这里是依赖注入发生的地方 try { bw.setPropertyValues(new MutablePropertyValues(deepCopy)); } catch (BeansException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex); } } 以上就是属性依赖注入的过程，我们再看一下属性值的解析，点开valueResolver.resolveValueIfNecessary()方法。 属性值的解析：**resolveValueIfNecessary**进而看一下BeanDefinitionValueResolver的resolveValueIfNecessary public Object resolveValueIfNecessary(Object argName, Object value) { // We must check each value to see whether it requires a runtime reference // to another bean to be resolved. //对引用类型的属性进行解析 if (value instanceof RuntimeBeanReference) { RuntimeBeanReference ref = (RuntimeBeanReference) value; //调用引用类型属性的解析方法 return resolveReference(argName, ref); }//对属性值是引用容器中另一个Bean名称的解析else if (value instanceof RuntimeBeanNameReference) { String refName = ((RuntimeBeanNameReference) value).getBeanName(); refName = String.valueOf(doEvaluate(refName)); //从容器中获取指定名称的Bean if (!this.beanFactory.containsBean(refName)) { throw new BeanDefinitionStoreException( “Invalid bean name ‘“ + refName + “‘ in bean reference for “ + argName); } return refName; } //对Bean类型属性的解析，主要是Bean中的内部类 else if (value instanceof BeanDefinitionHolder) { // Resolve BeanDefinitionHolder: contains BeanDefinition with name and aliases. BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value; return resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition()); } else if (value instanceof BeanDefinition) { // Resolve plain BeanDefinition, without contained name: use dummy name. BeanDefinition bd = (BeanDefinition) value; String innerBeanName = “(inner bean)” + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(bd); return resolveInnerBean(argName, innerBeanName, bd); } //对集合数组类型的属性解析 else if (value instanceof ManagedArray) { // May need to resolve contained runtime references. ManagedArray array = (ManagedArray) value; //获取数组的类型 Class&lt;?&gt; elementType = array.resolvedElementType; if (elementType == null) { //获取数组元素的类型 String elementTypeName = array.getElementTypeName(); if (StringUtils.hasText(elementTypeName)) { try { //使用反射机制创建指定类型的对象 elementType = ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader()); array.resolvedElementType = elementType; } catch (Throwable ex) { // Improve the message by showing the context. throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, &quot;Error resolving array type for &quot; + argName, ex); } } else { //没有获取到数组的类型，也没有获取到数组元素的类型，则直接设置数 组的类型为Object elementType = Object.class; } } //创建指定类型的数组 return resolveManagedArray(argName, (List&lt;?&gt;) value, elementType); } else if (value instanceof ManagedList) { // May need to resolve contained runtime references. return resolveManagedList(argName, (List&lt;?&gt;) value); } else if (value instanceof ManagedSet) { // May need to resolve contained runtime references. return resolveManagedSet(argName, (Set&lt;?&gt;) value); } else if (value instanceof ManagedMap) { // May need to resolve contained runtime references. return resolveManagedMap(argName, (Map&lt;?, ?&gt;) value); } //解析props类型的属性值，props其实就是key和value均为字符串的map else if (value instanceof ManagedProperties) { Properties original = (Properties) value; //创建一个拷贝，用于作为解析后的返回值 Properties copy = new Properties(); for (Map.Entry&lt;Object, Object&gt; propEntry : original.entrySet()) { Object propKey = propEntry.getKey(); Object propValue = propEntry.getValue(); if (propKey instanceof TypedStringValue) { propKey = evaluate((TypedStringValue) propKey); } if (propValue instanceof TypedStringValue) { propValue = evaluate((TypedStringValue) propValue); } copy.put(propKey, propValue); } return copy; } //解析字符串类型的属性值 else if (value instanceof TypedStringValue) { // Convert value to target type here. TypedStringValue typedStringValue = (TypedStringValue) value; Object valueObject = evaluate(typedStringValue); try { //获取属性的目标类型 Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue); if (resolvedTargetType != null) { return this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType); } else { //没有获取到属性的目标对象，则按Object类型返回 return valueObject; } } catch (Throwable ex) { // Improve the message by showing the context. throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, &quot;Error converting typed String value for &quot; + argName, ex); } } else { return evaluate(value); } } 属性值的依赖注入setPropertyValue点开AbstractAutowireCapableBeanFactory类的applyPropertyValues方法最后setPropertyValues 实现类AbstractPropertyAccessor @Override public void setPropertyValue(PropertyValue pv) throws BeansException { setPropertyValue(pv.getName(), pv.getValue()); }@Override public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid) throws BeansException { List&lt;PropertyAccessException&gt; propertyAccessExceptions = null; List&lt;PropertyValue&gt; propertyValues = (pvs instanceof MutablePropertyValues ? ((MutablePropertyValues) pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues())); for (PropertyValue pv : propertyValues) { try { // This method may throw any BeansException, which won&apos;t be caught // here, if there is a critical failure such as no matching field. // We can attempt to deal only with less serious exceptions. setPropertyValue(pv); } catch (NotWritablePropertyException ex) { if (!ignoreUnknown) { throw ex; } // Otherwise, just ignore it and continue... } catch (NullValueInNestedPathException ex) { if (!ignoreInvalid) { throw ex; } // Otherwise, just ignore it and continue... } catch (PropertyAccessException ex) { if (propertyAccessExceptions == null) { propertyAccessExceptions = new LinkedList&lt;PropertyAccessException&gt;(); } propertyAccessExceptions.add(ex); } } // If we encountered individual exceptions, throw the composite exception. if (propertyAccessExceptions != null) { PropertyAccessException\[\] paeArray = propertyAccessExceptions.toArray(new PropertyAccessException\[propertyAccessExceptions.size()\]); throw new PropertyBatchUpdateException(paeArray); } } 好了，自此，依赖注入部分就完了。]]></content>
      <categories>
        <category>Spring源码分析-IOC（五）依赖注入</category>
      </categories>
      <tags>
        <tag>Spring源码分析-IOC（五）依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-IOC（四）BeanDefinition解析和注册]]></title>
    <url>%2F2017%2F04%2F21%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-ioc-ef-bc-88-e5-9b-9b-ef-bc-89beandefinition-e8-a7-a3-e6-9e-90-e5-92-8c-e6-b3-a8-e5-86-8c%2F</url>
    <content type="text"><![CDATA[BeanDefinition解析上文说到按照Spring的Bean规则将document转换成BeanDefinition是由BeanDefinitionDocumentReader完成。BeanDefinitionDocumentReader调用了registerBeanDefinitions方法而这个方法又调用了doRegisterBeanDefinitions方法。 protected void doRegisterBeanDefinitions(Element root) { BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String\[\] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI\_VALUE\_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { return; } } } // 解析Bean定义之前, 增强解析过程的可扩展性 preProcessXml(root); // 从Document的根元素开始进行Bean定义的Document对象parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent; } protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { parseDefaultElement(ele, delegate); } else { delegate.parseCustomElement(ele); } } } } else { delegate.parseCustomElement(root); } } private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED\_BEANS\_ELEMENT)) { // recurse doRegisterBeanDefinitions(ele); } } 由于篇幅原因我们就看一下Bean标签的的解析 //由BeanDefinitionParserDelegate进行解析，将结果存放到BeanDefinitionHolderprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { //BeanDefinitionHolder是BeanDefinition的封装，封装了BeanDefinition，bean的名字别名等 //用BeanDefinitionHolder来向IOC容器注册 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. //向IOC容器注册Bean BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(“Failed to register bean definition with name ‘“ + bdHolder.getBeanName() + “‘“, ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } spring的BeanDefinition解析是在BeanDefinitionParserDelegate完成的。解析完成以后会把解析结果放到BeanDefinition对象中并设置到BeanDefinitionHolder中去。继续向下就会看到对Bean的id name等属性的处理。 //调用入口 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null); } /\*\* \* Parses the supplied {@code &lt;bean&gt;} element. May return {@code null} \* if there were errors during parse. Errors are reported to the \* {@link org.springframework.beans.factory.parsing.ProblemReporter}. */ public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) { //取得&lt;Bean&gt;元素中定义的ID name 和Alaiase属性的值 String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); if (StringUtils.hasLength(nameAttr)) { String\[\] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI\_VALUE\_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isDebugEnabled()) { logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName + &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;); } } if (containingBean == null) { checkNameUniqueness(beanName, aliases, ele); } //这个方法是对Bean元素的详细解析 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) { if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isDebugEnabled()) { logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - &quot; + &quot;using generated bean name \[&quot; + beanName + &quot;\]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String\[\] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null; } 上面介绍了对bean元素进行解析的过程，也就是BeanDefinition根据xml对bean定义而被创建的过程。其实这个BeanDefinition就是对Bean的抽象定义。继续看一下如何对Bean元素的解析 public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); //这里只读取&lt;Bean&gt;中定义的class名字，然后载入到BeanDefinition String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } try { String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } //这里生成需要的BeanDefinition对象，为Bean定义信息的载入做准备 AbstractBeanDefinition bd = createBeanDefinition(className, parent); //这里对Bean元素进行属性解析 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //对各种BEAN元素信息进行解析 parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); parseConstructorArgElements(ele, bd); parsePropertyElements(ele, bd); parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(&quot;Bean class \[&quot; + className + &quot;\] not found&quot;, ele, ex); } catch (NoClassDefFoundError err) { error(&quot;Class that bean class \[&quot; + className + &quot;\] depends on not found&quot;, ele, err); } catch (Throwable ex) { error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); } finally { this.parseState.pop(); } return null; } 元素解析已经完了，而元素属性及其子元素的解析顺序为： 1，解析元素的属性。 2，解析子元素。 3，解析子元素。 4，解析子元素。 5，解析子元素。 6，解析子元素。 7，解析子元素。 8，解析子元素。解析过程中像、等子元素都很少使用。 而下面就直接解析最常用的子元素子元素。这里我们只对Property进行解析，点开parsePropertyElements方法解析property子元素来完成对BeanDefinition载入过程。 public void parsePropertyElements(Element beanEle, BeanDefinition bd) {// 遍历所有的子元素 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) { parsePropertyElement((Element) node, bd); } } } /\*\* \* Parse a property element. */ public void parsePropertyElement(Element ele, BeanDefinition bd) { // 元素name属性 String propertyName = ele.getAttribute(NAME_ATTRIBUTE); if (!StringUtils.hasLength(propertyName)) { error(“Tag ‘property’ must have a ‘name’ attribute”, ele); return; } this.parseState.push(new PropertyEntry(propertyName)); try {// 如果同一个Bean中已经有相同名字的存在, 直接返回// 也就是说, 如果一个Bean中定义了两个名字一样的元素, 只有第一个起作用. if (bd.getPropertyValues().contains(propertyName)) { error(“Multiple ‘property’ definitions for property ‘“ + propertyName + “‘“, ele); return; }// 解析元素, 返回的对象对应元素的解析结果, 最终封装到PropertyValue中, 并设置到BeanDefinitionHolder中 Object val = parsePropertyValue(ele, bd, propertyName); PropertyValue pv = new PropertyValue(propertyName, val); parseMetaElements(ele, pv); pv.setSource(extractSource(ele)); bd.getPropertyValues().addPropertyValue(pv); } finally { this.parseState.pop(); } }/** * Get the value of a property element. May be a list etc. * Also used for constructor arguments, “propertyName” being null in this case. */ public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) { String elementName = (propertyName != null) ? “ element for property ‘“ + propertyName + “‘“ : “ element”; // 检查&lt;property&gt;的子元素, 只能是ref, value, list等(description, meta除外)其中的一个. NodeList nl = ele.getChildNodes(); Element subElement = null; for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp; !nodeNameEquals(node, META_ELEMENT)) { // Child element is what we&apos;re looking for. if (subElement != null) { error(elementName + &quot; must not contain more than one sub-element&quot;, ele); } else { subElement = (Element) node; } } } // 判断property元素是否含有ref和value属性, 不允许既有ref又有value属性.// 同时也不允许ref和value属性其中一个与子元素共存. boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE); boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE); if ((hasRefAttribute &amp;&amp; hasValueAttribute) || ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) { error(elementName + “ is only allowed to contain either ‘ref’ attribute OR ‘value’ attribute OR sub-element”, ele); } // 如果属性是ref属性, 创建一个ref的数据对象RuntimeBeanReference, 封装了ref信if (hasRefAttribute) { String refName = ele.getAttribute(REF_ATTRIBUTE); if (!StringUtils.hasText(refName)) { error(elementName + “ contains empty ‘ref’ attribute”, ele); } RuntimeBeanReference ref = new RuntimeBeanReference(refName); ref.setSource(extractSource(ele)); return ref; }// 如果属性是value属性, 创建一个数据对象TypedStringValue, 封装了value信息 else if (hasValueAttribute) { TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE)); valueHolder.setSource(extractSource(ele)); return valueHolder; }// 如果当前元素还有子元素 else if (subElement != null) { return parsePropertySubElement(subElement, bd); } else { // 以上都不是, 说明配置错误, 返回null. // Neither child element nor “ref” or “value” attribute found. error(elementName + “ must specify a ref or value”, ele); return null; } } 如果property子元素还有子元素 public Object parsePropertySubElement(Element ele, BeanDefinition bd, String defaultValueType) { // 如果子元素没有使用Spring默认命名空间, 则使用用户自定义的规则解析 if (!isDefaultNamespace(ele)) { return parseNestedCustomElement(ele, bd); }// 如果子元素是bean元素, 则使用解析元素的方法解析 else if (nodeNameEquals(ele, BEAN_ELEMENT)) { BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd); if (nestedBd != null) { nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd); } return nestedBd; } // 如果子元素是ref, 有且只能有bean、local和parent 3个属性中的一个 else if (nodeNameEquals(ele, REF_ELEMENT)) { // A generic reference to any name of any bean.// 引用普通任意的bean String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); boolean toParent = false; if (!StringUtils.hasLength(refName)) { // A reference to the id of another bean in the same XML file. // 引用同一个XML配置文件中的bean refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE); if (!StringUtils.hasLength(refName)) { // A reference to the id of another bean in a parent context. // 引用父容器中的bean refName = ele.getAttribute(PARENT_REF_ATTRIBUTE); toParent = true; if (!StringUtils.hasLength(refName)) { error(“‘bean’, ‘local’ or ‘parent’ is required for element”, ele); return null; } } }// ref元素没有bean、local和parent 3个属性中的一个, 返回null. if (!StringUtils.hasText(refName)) { error(“ element contains empty target attribute”, ele); return null; } RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent); ref.setSource(extractSource(ele)); return ref; } else if (nodeNameEquals(ele, IDREF_ELEMENT)) { return parseIdRefElement(ele); } else if (nodeNameEquals(ele, VALUE_ELEMENT)) { return parseValueElement(ele, defaultValueType); } else if (nodeNameEquals(ele, NULL_ELEMENT)) { // It’s a distinguished null value. Let’s wrap it in a TypedStringValue // object in order to preserve the source location. TypedStringValue nullHolder = new TypedStringValue(null); nullHolder.setSource(extractSource(ele)); return nullHolder; } else if (nodeNameEquals(ele, ARRAY_ELEMENT)) { return parseArrayElement(ele, bd); }//如果是List子元素 else if (nodeNameEquals(ele, LIST_ELEMENT)) { return parseListElement(ele, bd); } else if (nodeNameEquals(ele, SET_ELEMENT)) { return parseSetElement(ele, bd); } else if (nodeNameEquals(ele, MAP_ELEMENT)) { return parseMapElement(ele, bd); } else if (nodeNameEquals(ele, PROPS_ELEMENT)) { return parsePropsElement(ele); } else { error(“Unknown property sub-element: [“ + ele.getNodeName() + “]“, ele); return null; } } 我们以解析List为例 /** * Parse a list element. */ public List parseListElement(Element collectionEle, BeanDefinition bd) {// 获取元素中的value-type属性, 即集合元素的数据类型String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE); // 元素所有子节点NodeList nl = collectionEle.getChildNodes(); ManagedList target = new ManagedList(nl.getLength()); target.setSource(extractSource(collectionEle)); target.setElementTypeName(defaultElementType); target.setMergeEnabled(parseMergeAttribute(collectionEle)); // 具体解析List元素中的值 parseCollectionElements(nl, target, bd, defaultElementType); return target; } /\*\* \* Parse a set element. */ protected void parseCollectionElements( NodeList elementNodes, Collection&lt;Object&gt; target, BeanDefinition bd, String defaultElementType) { // 遍历集合所有子节点 for (int i = 0; i &lt; elementNodes.getLength(); i++) { Node node = elementNodes.item(i); if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {// 如果子节点是Element且不是节点, 则添加进ManagedList.// 同时触发对下层子元素的解析, 递归调用. target.add(parsePropertySubElement((Element) node, bd, defaultElementType)); } } } 经过这样逐层的分析，我们在xml文件中定义的BeanDefinition就被整个载入到IOC容器中，并在容器中建立了数据映射。在IOC容器中建立了对应的数据结构，或者说可以看成POJO对象在IOC容器中的抽象，这些数据结构可以以AbstractBeanDefinition为入口让IOC容器执行索引，查询和操作。 BeanDefinition注册DefaultBeanDefinitionDocumentReader**的**processBeanDefinition方法对Bean进行回调注册 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // 注册BeanDefinition BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(“Failed to register bean definition with name ‘“ + bdHolder.getBeanName() + “‘“, ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 点开registerBeanDefinition方法 public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { // Register bean definition under primary name. String beanName = definitionHolder.getBeanName(); // 向IoC容器注册BeanDefinition registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // 如果解析的BeanDefinition有别名, 向容器为其注册别名. . String\[\] aliases = definitionHolder.getAliases(); if (aliases != null) { for (String aliase : aliases) { registry.registerAlias(beanName, aliase); } } } 上面的registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())是调用的注册位置，而BeanDefinitionRegistry仅仅是一个接口，而真正实现它的却是最原本的DefaultListableBeanFactory.registerBeanDefinition方法 public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, &quot;Bean name must not be empty&quot;); Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;); // 对解析得到的BeanDefinition校验 if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, “Validation of bean definition failed”, ex); } } BeanDefinition oldBeanDefinition; oldBeanDefinition = this.beanDefinitionMap.get(beanName); if (oldBeanDefinition != null) { if (!this.allowBeanDefinitionOverriding) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, &quot;Cannot register bean definition \[&quot; + beanDefinition + &quot;\] for bean &apos;&quot; + beanName + &quot;&apos;: There is already \[&quot; + oldBeanDefinition + &quot;\] bound.&quot;); } else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) { // e.g. was ROLE\_APPLICATION, now overriding with ROLE\_SUPPORT or ROLE_INFRASTRUCTURE if (this.logger.isWarnEnabled()) { this.logger.warn(&quot;Overriding user-defined bean definition for bean &apos;&quot; + beanName + &quot; with a framework-generated bean definition &apos;: replacing \[&quot; + oldBeanDefinition + &quot;\] with \[&quot; + beanDefinition + &quot;\]&quot;); } } else { if (this.logger.isInfoEnabled()) { this.logger.info(&quot;Overriding bean definition for bean &apos;&quot; + beanName + &quot;&apos;: replacing \[&quot; + oldBeanDefinition + &quot;\] with \[&quot; + beanDefinition + &quot;\]&quot;); } } } else { this.beanDefinitionNames.add(beanName); this.manualSingletonNames.remove(beanName); this.frozenBeanDefinitionNames = null; } this.beanDefinitionMap.put(beanName, beanDefinition); if (oldBeanDefinition != null || containsSingleton(beanName)) { resetBeanDefinition(beanName); } } 完成了BeanDefinition的注册，就完成了IOC容器的初始化过程，此时使用的IOC容器DefinListableBeanFactory中已经建立了整个Bean的配置信息，而且这些BeanDefinition已经可以被容器使用了，他们都BeanDefintionMap被检索和使用。容器的作用就是对这些信息进行处理和维护，这些信息就是容器建立依赖反转的基础。]]></content>
      <categories>
        <category>Spring源码分析-IOC（四）BeanDefinition解析和注册</category>
      </categories>
      <tags>
        <tag>Spring源码分析-IOC（四）BeanDefinition解析和注册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-IOC（三）容器初始化]]></title>
    <url>%2F2017%2F04%2F21%2Fspring-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-ioc-ef-bc-88-e4-b8-89-ef-bc-89-e5-ae-b9-e5-99-a8-e5-88-9d-e5-a7-8b-e5-8c-96%2F</url>
    <content type="text"><![CDATA[IOC的初始化又refresh方法来启动，这个过程包括Resource定位，BeanDefinitionl载入，BeanDefinitionl注册。这个过程一般不包括Bean的依赖注入，在ioc设计中Bean的载入和依赖注入是两个独立的过程，依赖注入一般发生在第一次getBean向容器索要Bean的时候。（单例Bean默认配置了lazyinit属性为ture，实例化会在ioc容器初始化的时候提前完成） 上文说容器的启动大同小异，基本操作封装在一个基类，这个基类就是AbstractApplicationContext。ClassPathXmlApplicationContext的refresh()实际上就是调用了AbstractApplicationContext的refresh()方法。 public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // 准备刷新容器, 获取容器的当时时间, 同时给容器设置同步标识 prepareRefresh(); // 启动子类的refreshBeanFactory方法. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 为BeanFactory配置容器特性，例如类加载器、事件处理器等. prepareBeanFactory(beanFactory); try { // 设置BeanFactory的后置处理. postProcessBeanFactory(beanFactory); // 调用BeanFactory的后处理器, 这些后处理器是在Bean定义中向容器注册的. invokeBeanFactoryPostProcessors(beanFactory); // 注册Bean的后处理器, 在Bean创建过程中调用. registerBeanPostProcessors(beanFactory); // 初始化上下文中的消息源. initMessageSource(); // 初始化上下文中的事件机制. initApplicationEventMulticaster(); // 初始化其它特殊的Bean. onRefresh(); // 检查并向容器注册监听器Bean. registerListeners(); // 实例化所有剩余的(non-lazy-init) 单例Bean. finishBeanFactoryInitialization(beanFactory); // 发布容器事件, 结束refresh过程. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // 销毁已经创建的单例Bean, 以避免资源占用. destroyBeans(); // 取消refresh操作, 重置 &apos;active&apos; 标志. cancelRefresh(ex); throw ex; } finally { //重置Spring的核心缓存 resetCommonCaches(); } } } Resources定位obtainFreshBeanFactory()中调用了refreshBeanFactory()，而refreshBeanFactory的实现在AbstractRefreshableApplicationContext protected final void refreshBeanFactory() throws BeansException { //如果建立了BeanFactory则关闭销毁BeanFactory if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { //创建并设置DefaultListableBeanFactory同时调用loadBeanDefinitions载入loadBeanDefinition DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(“I/O error parsing bean definition source for “ + getDisplayName(), ex); } }//在上下文中创建DefaultListableBeanFactoryprotected DefaultListableBeanFactory createBeanFactory() { return new DefaultListableBeanFactory(getInternalParentBeanFactory()); } 这里我们看一下loadBeanDefinitions其具体实现在AbstractXmlApplicationContext protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // Create a new XmlBeanDefinitionReader for the given BeanFactory. //创建一个beanDefinitionReader，并通过回调设置到BeanFactory中去 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context&apos;s // resource loading environment. //为XmlBeanDefinitionReader配一个ResourceLoader beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); //为Bean读取器设置SAX xml解析器 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); //Bean读取器真正实现的地方 loadBeanDefinitions(beanDefinitionReader); } protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { Resource\[\] configResources = getConfigResources(); if (configResources != null) { reader.loadBeanDefinitions(configResources); } String\[\] configLocations = getConfigLocations(); if (configLocations != null) { reader.loadBeanDefinitions(configLocations); } } 程序首先首先创建一个Reader，每一类资源都对应着一个BeanDefinitionReader，BeanDefinitionReader提供统一的转换规则；然后设置Reader，最后调用loadBeanDefinition，该loadBeanDefinition才是读取器真正实现的地方。而getConfigResources采用模板方法设计模式，具体的实现由之类完成，实际上这里getConfigResources调用的就是ClassPathXmlApplicationContext的getConfigResources方法。 从图中可以看出ClassPathXmlApplicationContext继承了DefaultResourceLoader，具备了Resource加载资源的功能。至此完成了Resource定位！ BeanDefinition载入继续向下看loadBeanDefinitions是如何载入的 public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException { Assert.notNull(resources, &quot;Resource array must not be null&quot;); int counter = 0; //遍历所有Resource集合loadBeanDefinition的信息 for (Resource resource : resources) { counter += loadBeanDefinitions(resource); } return counter; } //调用入口 public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { return loadBeanDefinitions(new EncodedResource(resource)); } //载入xml形式的BeanDefinition的地方 public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isInfoEnabled()) { logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource()); } Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); } try { //得到xml的InputStream InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } //具体的读入过程 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } } } protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { //取得xml文件的Document,解析过程是由DocumentLoader完成，默认为DefaultDocumentLoader Document doc = doLoadDocument(inputSource, resource); //启动对BeanDefinition的详细解析过程，这个解析会使用到spring的BEAN配置规则 return registerBeanDefinitions(doc, resource); } catch (BeanDefinitionStoreException ex) { throw ex; } catch (SAXParseException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), “Line “ + ex.getLineNumber() + “ in XML document from “ + resource + “ is invalid”, ex); } catch (SAXException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), “XML document from “ + resource + “ is invalid”, ex); } catch (ParserConfigurationException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), “Parser configuration exception parsing XML from “ + resource, ex); } catch (IOException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), “IOException parsing XML document from “ + resource, ex); } catch (Throwable ex) { throw new BeanDefinitionStoreException(resource.getDescription(), “Unexpected exception parsing XML document from “ + resource, ex); } } 得到了xml的document对象，怎么按照Spring的Bean规则将document转换成BeanDefinitionDocument呢？这个过程是由BeanDefinitionDocumentReader完成的，这里的registerBeanDefinitions还对载入Bean的数量进行了统计 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { //得到BeanDefinitionDocumentReader对xml进行解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); //具体解析过程在这个registerBeanDefinitions中完成 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore; } 至此就完成了BeanDefinition的载入，BeanDefinition的载入分为两个部分，首先通过调用xml解析器得到的document对象，但是这个对象并没有按照spring的bean规则进行解析。在完成xml解析之后，才是按照Spring的Bean规则进行解析，这个解析过程在DocumentReader中完成的，这里使用的是默认的DefaultBeanDefinitionDocumentReader。]]></content>
      <categories>
        <category>Spring源码分析-IOC（三）容器初始化</category>
      </categories>
      <tags>
        <tag>Spring源码分析-IOC（三）容器初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-IOC（二）入门]]></title>
    <url>%2F2017%2F04%2F20%2Fspringioc-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90%2F</url>
    <content type="text"><![CDATA[ClassPathXmlApplicationContext介绍ApplicationContext是spring中较高级的容器。和BeanFactory类似，它可以加载配置文件中定义的bean，将所有的bean集中在一起，当有请求的时候分配bean。 另外，它增加了企业所需要的功能，比如，从属性文件从解析文本信息和将事件传递给所指定的监听器。这个容器在org.springframework.context.ApplicationContext接口中定义。ApplicationContext包含BeanFactory所有的功能，一般情况下，相对于BeanFactory，ApplicationContext会被推荐使用。但BeanFactory仍然可以在轻量级应用中使用，比如移动设备或者基于applet的应用程序。 ApplicationContext接口关系1.支持不同的信息源。扩展了MessageSource接口，这个接口为ApplicationContext提供了很多信息源的扩展功能，比如：国际化的实现为多语言版本的应用提供服务。2.访问资源。这一特性主要体现在ResourcePatternResolver接口上，对Resource和ResourceLoader的支持，这样我们可以从不同地方得到Bean定义资源。 这种抽象使用户程序可以灵活地定义Bean定义信息，尤其是从不同的IO途径得到Bean定义信息。这在接口上看不出来，不过一般来说，具体ApplicationContext都是继承了DefaultResourceLoader的子类。因为DefaultResourceLoader是AbstractApplicationContext的基类，关于Resource后面会有更详细的介绍。 3.支持应用事件。继承了接口ApplicationEventPublisher，为应用环境引入了事件机制，这些事件和Bean的生命周期的结合为Bean的管理提供了便利。 4.附件服务。EnvironmentCapable里的服务让基本的Ioc功能更加丰富。 5.ListableBeanFactory和HierarchicalBeanFactory是继承的主要容器。 最常被使用的ApplicationContext接口实现类： 1，FileSystemXmlApplicationContext：该容器从XML文件中加载已被定义的bean。在这里，你需要提供给构造器XML文件的完整路径。 2，ClassPathXmlApplicationContext：该容器从XML文件中加载已被定义的bean。在这里，你不需要提供XML文件的完整路径，只需正确配置CLASSPATH 环境变量即可，因为，容器会从CLASSPATH中搜索bean配置文件。 3，WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在XML文件中 准备工作需要一个message类 public class Message { public void sayMessage(){ System.out.println(“IOC Message!!!”); }}还需要一个写一个spring的配置文件spring.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 还需要一个测试类 public class Message_Test { @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(“spring.xml”); Message bean = context.getBean(“message”, Message.class); bean.sayMessage(); }} 好了准备工作完成好了，我们先看一下这个ClassPathXmlApplicationContext里面是做了什么。 public ClassPathXmlApplicationContext(String configLocation) throws BeansException { this(new String[] {configLocation}, true, null); }//这个构造方法实际上是调用了下面public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException { super(parent); setConfigLocations(configLocations); if (refresh) { refresh(); } } 先看一下这个super() 里面做了什么（注意，这里传递过来的parent为null），追踪发现在AbstractApplicationContext类中调用了setParent(parent); private ApplicationContext parent;//其实就是把ApplicationContext作为父容器@Override public void setParent(ApplicationContext parent) { this.parent = parent; if (parent != null) { Environment parentEnvironment = parent.getEnvironment(); if (parentEnvironment instanceof ConfigurableEnvironment) { getEnvironment().merge((ConfigurableEnvironment) parentEnvironment); } } } 接着回到ClassPathXmlApplicationContext的构造方法看一下 下一句代码setConfigLocations()，追踪代码可以找到在PropertyPlaceholderHelper类中的parseStringValue()方法进行了字符串替换 ，path 路径中含有 ${user.dir} ，则将替换为： System.getProperty(user.dir); protected String parseStringValue( String strVal, PlaceholderResolver placeholderResolver, Set visitedPlaceholders) { StringBuilder result = new StringBuilder(strVal); int startIndex = strVal.indexOf(this.placeholderPrefix); while (startIndex != -1) { int endIndex = findPlaceholderEndIndex(result, startIndex); if (endIndex != -1) { String placeholder = result.substring(startIndex + this.placeholderPrefix.length(), endIndex); String originalPlaceholder = placeholder; if (!visitedPlaceholders.add(originalPlaceholder)) { throw new IllegalArgumentException( &quot;Circular placeholder reference &apos;&quot; + originalPlaceholder + &quot;&apos; in property definitions&quot;); } // Recursive invocation, parsing placeholders contained in the placeholder key. //这里递归查找 placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders); // Now obtain the value for the fully resolved key... String propVal = placeholderResolver.resolvePlaceholder(placeholder); if (propVal == null &amp;&amp; this.valueSeparator != null) { int separatorIndex = placeholder.indexOf(this.valueSeparator); if (separatorIndex != -1) { String actualPlaceholder = placeholder.substring(0, separatorIndex); String defaultValue = placeholder.substring(separatorIndex + this.valueSeparator.length()); //这里是调用了实现PropertyPlaceholderHelper内部接口PlaceholderResolver方法resolvePlaceholder //：占位符 key -&gt; value propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder); if (propVal == null) { propVal = defaultValue; } } } if (propVal != null) { // Recursive invocation, parsing placeholders contained in the // previously resolved placeholder value. propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders); //// 替换占位符具体值 result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal); if (logger.isTraceEnabled()) { logger.trace(&quot;Resolved placeholder &apos;&quot; + placeholder + &quot;&apos;&quot;); } startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length()); } else if (this.ignoreUnresolvablePlaceholders) { // Proceed with unprocessed value. startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length()); } else { throw new IllegalArgumentException(&quot;Could not resolve placeholder &apos;&quot; + placeholder + &quot;&apos;&quot; + &quot; in string value \\&quot;&quot; + strVal + &quot;\\&quot;&quot;); } visitedPlaceholders.remove(originalPlaceholder); } else { startIndex = -1; } } return result.toString(); } 再回到ClassPathXmlApplicationContext中，因为refresh为true，所以要执行refresh方法，这个refresh会牵扯一系列复杂操作，对于不同容器，实现都是类似的，所以封装在一个基类中完成，而在ClassPathXmlApplicationContext看到的只是一些简单的调用。]]></content>
      <categories>
        <category>Spring源码分析-IOC（二）入门</category>
      </categories>
      <tags>
        <tag>Spring源码分析-IOC（二）入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析-IOC（一）容器]]></title>
    <url>%2F2017%2F04%2F19%2Fspringioc-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-e4-b8-80-ef-bc-88-e5-ae-b9-e5-99-a8-ef-bc-89%2F</url>
    <content type="text"><![CDATA[容器概述IoC也被称作依赖注入(DI)。它是一个处理对象依赖项的过程，也就是将他们一起工作的其他的对象，只有通过构造参数、工厂方法参数或者（属性注入）通过构造参数实例化或通过工厂方法返回对象后再设置属性。当创建bean后，IoC容器再将这些依赖项注入进去。这个过程基本上是反转的，因此得名控制反转（IoC）。 IoC容器利用Java的POJO类和配置元数据来生成 完全配置和可执行 的系统或应用程序。而Bean在Spring中就是POJO，也可以认为Bean就是对象。 接口设计 这里主要是接口体系，而具体实现体系，比如DefaultListableBeanFactory就是为了实现ConfigurableBeanFactory，从而成为一个简单Ioc容器实现。与其他Ioc容器类似，XmlBeanFactory就是为了实现BeanFactory，但都是基于DefaultListableBeanFactory的基础做了扩展。同样的，ApplicationContext也一样。 从图中我们可以简要的做出以下分析： 1.从接口BeanFactory到HierarchicalBeanFactory，再到ConfigurableBeanFactory,这是一条主要的BeanFactory设计路径。在这条接口设计路径中，BeanFactory，是一条主要的BeanFactory设计路径。在这条接口设计路径中，BeanFactory接口定义了基本的Ioc容器的规范。在这个接口定义中，包括了getBean()这样的Ioc容器的基本方法（通过这个方法可以从容器中取得Bean）。而HierarchicalBeanFactory接口在继承了BeanFactory的基本接口后，增加了getParentBeanFactory()的接口功能，使BeanFactory具备了双亲Ioc容器的管理功能。在接下来的ConfigurableBeanFactory接口中，主要定义了一些对BeanFactory的配置功能，比如通过setParentBeanFactory()设置双亲Ioc容器，通过addBeanPostProcessor()配置Bean后置处理器，等等。通过这些接口设计的叠加，定义了BeanFactory就是最简单的Ioc容器的基本功能。 2.第二条接口设计主线是，以ApplicationContext作为核心的接口设计，这里涉及的主要接口设计有，从BeanFactory到ListableBeanFactory，再到ApplicationContext，再到我们常用的WebApplicationContext或者ConfigurableApplicationContext接口。我们常用的应用基本都是org.framework.context 包里的WebApplicationContext或者ConfigurableApplicationContext实现。在这个接口体现中，ListableBeanFactory和HierarchicalBeanFactory两个接口，连接BeanFactory接口定义和ApplicationContext应用的接口定义。在ListableBeanFactory接口中，细化了许多BeanFactory的接口功能，比如定义了getBeanDefinitionNames()接口方法；对于ApplicationContext接口，它通过继承MessageSource、ResourceLoader、ApplicationEventPublisher接口，在BeanFactory简单Ioc容器的基础上添加了许多对高级容器的特性支持。 3.这个接口系统是以BeanFactory和ApplicationContext为核心设计的，而BeanFactory是Ioc容器中最基本的接口，在ApplicationContext的设计中，一方面，可以看到它继承了BeanFactory接口体系中的ListableBeanFactory、AutowireCapableBeanFactory、HierarchicalBeanFactory等BeanFactory的接口，具备了BeanFactory Ioc容器的基本功能；另一方面，通过继承MessageSource、ResourceLoadr、ApplicationEventPublisher这些接口，BeanFactory为ApplicationContext赋予了更高级的Ioc容器特性。对于ApplicationContext而言，为了在Web环境中使用它，还设计了WebApplicationContext接口，而这个接口通过继承ThemeSource接口来扩充功能。 BeanFactory的接口体系最原始的容器：BeanFactorypackage org.springframework.beans.factory; import org.springframework.beans.BeansException;import org.springframework.core.ResolvableType; /** * BeanFactory作为最原始同时也最重要的Ioc容器,它主要的功能是为依赖注入 （DI） 提供支持， BeanFactory 和相关的接口，比如，BeanFactoryAware、 * DisposableBean、InitializingBean，仍旧保留在 Spring 中，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。在 Spring 中 * ，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一 * 个被配置化的系统或者应用。在资源宝贵的移动设备或者基于applet的应用当中， BeanFactory 会被优先选择。否则，一般使用的是 ApplicationContext * * 这里定义的只是一系列的接口方法，通过这一系列的BeanFactory接口，可以使用不同的Bean的检索方法很方便地从Ioc容器中得到需要的Bean，从而忽略具体 * 的Ioc容器的实现，从这个角度上看，这些检索方法代表的是最为基本的容器入口。 * * @author Rod Johnson * @author Juergen Hoeller * @author Chris Beams * @since 13 April 2001 */public interface BeanFactory { /\*\* \* 转定义符&quot;&amp;&quot; 用来引用实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;a会得到那个Factory \* \* FactoryBean和BeanFactory 是在Spring中使用最为频繁的类，它们在拼写上很相似。一个是Factory，也就是Ioc容器或对象工厂；一个 \* 是Bean。在Spring中，所有的Bean都是由BeanFactory（也就是Ioc容器）来进行管理的。但对FactoryBean而言，这个Bean不是简单的Be \* an，而是一个能产生或者修饰对象生成的工厂Bean，它的实现与设计模式中的工厂模式和修饰器模式类似。 */ String FACTORY\_BEAN\_PREFIX = &quot;&amp;&quot;; /\*\* \* 五个不同形式的getBean方法，获取实例 \* @param name 检索所用的Bean名 \* @return Object（&lt;T&gt; T） 实例对象 \* @throws BeansException 如果Bean不能取得 */ Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; /\*\* \* 让用户判断容器是否含有指定名字的Bean. \* @param name 搜索所用的Bean名 \* @return boolean 是否包含其中 */ boolean containsBean(String name); /\*\* \* 查询指定名字的Bean是否是Singleton类型的Bean. \* 对于Singleton属性，可以在BeanDefinition指定. \* @param name 搜索所用的Bean名 \* @return boolean 是否包是Singleton \* @throws NoSuchBeanDefinitionException 没有找到Bean */ boolean isSingleton(String name) throws NoSuchBeanDefinitionException; /\*\* \* 查询指定名字的Bean是否是Prototype类型的。 \* 与Singleton属性一样，可以在BeanDefinition指定. \* @param name 搜索所用的Bean名 \* @return boolean 是否包是Prototype \* @throws NoSuchBeanDefinitionException 没有找到Bean */ boolean isPrototype(String name) throws NoSuchBeanDefinitionException; /\*\* \* 查询指定了名字的Bean的Class类型是否是特定的Class类型. \* @param name 搜索所用的Bean名 \* @param typeToMatch 匹配类型 \* @return boolean 是否是特定类型 \* @throws NoSuchBeanDefinitionException 没有找到Bean */ boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; /\*\* \* 查询指定名字的Bean的Class类型. \* @param name 搜索所用的Bean名 \* @return 指定的Bean或者null(没有找到合适的Bean) \* @throws NoSuchBeanDefinitionException 没有找到Bean */ Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; /\*\* \* 查询指定了名字的Bean的所有别名，这些都是在BeanDefinition中定义的 \* @param name 搜索所用的Bean名 \* @return 指定名字的Bean的所有别名 或者一个空的数组 */ String\[\] getAliases(String name); } 容器的基础：XmlBeanFactorypackage org.springframework.beans.factory.xml; import org.springframework.beans.BeansException;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.support.DefaultListableBeanFactory;import org.springframework.core.io.Resource; /** * XmlBeanFactory是BeanFactory的最简单实现类 * * XmlBeanFactory的功能是建立在DefaultListableBeanFactory这个基本容器的基础上的，并在这个基本容器的基础上实行了其他诸如 * XML读取的附加功能。XmlBeanFactory使用了DefaultListableBeanFactory作为基础类，DefaultListableBeanFactory是一个很重 * 要的Ioc实现，会在下一章进行重点论述。 * * @author Rod Johnson * @author Juergen Hoeller * @author Chris Beams * @since 15 April 2001 */public class XmlBeanFactory extends DefaultListableBeanFactory { private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this); /\*\* \* 根据给定来源，创建一个XmlBeanFactory \* @param resource Spring中对与外部资源的抽象，最常见的是对文件的抽象，特别是XML文件。而且Resource里面通常 \* 是保存了Spring使用者的Bean定义，比如applicationContext.xml在被加载时，就会被抽象为Resource来处理。 \* @throws BeansException 载入或者解析中发生错误 */ public XmlBeanFactory(Resource resource) throws BeansException { this(resource, null); } /\*\* \* 根据给定来源和BeanFactory，创建一个XmlBeanFactory \* @param resource Spring中对与外部资源的抽象，最常见的是对文件的抽象，特别是XML文件。而且Resource里面通常 \* 是保存了Spring使用者的Bean定义，比如applicationContext.xml在被加载时，就会被抽象为Resource来处理。 \* @param parentBeanFactory 父类的BeanFactory \* @throws BeansException 载入或者解析中发生错误 */ public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException { super(parentBeanFactory); this.reader.loadBeanDefinitions(resource); } } 在XmlBeanFactory中实例化了一个XmlBeanDefinitionReader，这个Reader对象就是用来处理以xml形式的持有类信息的BeanDefinitionl类。在XmlBeanFactory这个容器中还需要BeanDefinitionl信息，这些信息被封装成Resource，然后把Resource传递给构造方法，然后再使用XmlBeanDefinitionReader进行处理，完成容器的初始化和注入。 下图是XmlBeanFactory的继承关系 作为简单ioc容器系列最底层的实现XmlBeanFactory是建立在defaultListableBeanFactory容器的基础之上的，并在这个基本容器的基础上实现了其他诸如xml读取的附加功能。 Resource**的接口体系** 资源的原始接口为Resource，它继承自InputStreamResource，实现了其getInstream方法，这样所有的资源就是通过该方法来获取输入流的。对于资源的加载，也实现了统一，定义了一个资源加载顶级接口ResourceLoader，它默认的加载就是DefaultResourceLoader。 InputStreamSource接口package org.springframework.core.io; import java.io.IOException;import java.io.InputStream; /** * InputStreamSource 封装任何能返回InputStream的类，比如File、Classpath下的资源和Byte Array等 * * @author Juergen Hoeller * @since 20.01.2004 */public interface InputStreamSource { /\*\* \* 返回InputStream的类，比如File、Classpath下的资源和Byte Array等 \* @return InputStream 返回一个新的InputStream的对象 \* @throws IOException 如果资源不能打开则抛出异常 */ InputStream getInputStream() throws IOException; } Resource接口package org.springframework.core.io; import java.io.File;import java.io.IOException;import java.net.URI;import java.net.URL; /** * Resource接口抽象了所有Spring内部使用到的底层资源：File、URL、Classpath等。 * 同时，对于来源不同的资源文件，Resource也有不同实现：文件(FileSystemResource)、Classpath资源(ClassPathResource)、 * URL资源(UrlResource)、InputStream资源(InputStreamResource)、Byte数组(ByteArrayResource)等等。 * * @author Juergen Hoeller * @since 28.12.2003 */public interface Resource extends InputStreamSource { /\*\* \* 判断资源是否存在 \* @return boolean 是否存在 */ boolean exists(); /\*\* \* 判断资源是否可读 \* @return boolean 是否可读 */ boolean isReadable(); /\*\* \* 是否处于开启状态 \* @return boolean 是否开启 */ boolean isOpen(); /\*\* \* 得到URL类型资源，用于资源转换 \* @return URL 得到URL类型 \* @throws IOException 如果资源不能打开则抛出异常 */ URL getURL() throws IOException; /\*\* \* 得到URI类型资源，用于资源转换 \* @return URI 得到URI类型 \* @throws IOException 如果资源不能打开则抛出异常 */ URI getURI() throws IOException; /\*\* \* 得到File类型资源，用于资源转换 \* @return File 得到File类型 \* @throws IOException 如果资源不能打开则抛出异常 */ File getFile() throws IOException; /\*\* \* 获取资源长度 \* @return long 资源长度 \* @throws IOException 如果资源不能打开则抛出异常 */ long contentLength() throws IOException; /\*\* \* 获取lastModified属性 \* @return long 获取lastModified \* @throws IOException 如果资源不能打开则抛出异常 */ long lastModified() throws IOException; /\*\* \* 创建一个相对的资源方法 \* @param relativePath 相对路径 \* @return Resource 返回一个新的资源 \* @throws IOException 如果资源不能打开则抛出异常 */ Resource createRelative(String relativePath) throws IOException; /\*\* \* 获取文件名称 \* @return String 文件名称或者null */ String getFilename(); /\*\* \* 得到错误处理信息，主要用于错误处理的信息打印 \* @return String 错误资源信息 */ String getDescription(); } 根据上面的推论，我们可以理解为这两段代码，在某种程度来说是完全等效的 ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;); InputStream inputStream = resource.getInputStream(); Resource resource = new ClassPathResource(&quot;applicationContext.xml&quot;); InputStream inputStream = resource.getInputStream(); 这样得到InputStream以后，我们可以拿来用了。值得一提是，不同的实现有不同的调用方法，这里就不展开了。 编程式使用Ioc容器说完了BeanFactory和resource体系，可以看到XmlBeanFactory使用DefaultListableBeanFactory作为基类，DefaultListableBeanFactory也是一个很重要的ioc容器，在其他的ioc容器中，譬如ApplicationContext的实现和XmlBeanFactory实现是类似的。编程式的使用DefaultListableBeanFactory可以了解容器的基本过程，还可以看一下几个关键类（resource，DefaultListableBeanFactory，XmlBeanDefinitionReader）之间的关系，如何分离解耦又如何结合为ioc容器服务 public class ProgramBeanFactory{ public static void main(String[] args) { ClassPathResource resource = new ClassPathResource(“applicationContext.xml”); DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory); reader.loadBeanDefinitions(resource); Message message = factory.getBean(“message”, Message.class); //Message是自己写的测试类 message.printMessage(); }} 以上，可以简单说明我们在使用Ioc容器时，需要如下几个步骤： 1，创建Ioc配置文件的抽象资源，这个抽象资源包含了BeanDefinition的定义信息。 2，创建一个BeanFactory，这里使用了DefaultListableBeanFactory。 3，创建一个载入BeanDefinition的读取器，这里使用XmlBeanDefinitionReader来载入XML文件形式的BeanDefinition，通过一个回调配置给BeanFactory。 4，从定义好的资源位置读入配置信息，具体的解析过程由XmlBeanDefinitionReader来完成。完成整个载入和注册Bean定义之后，需要的Ioc容器就建立起来了。这个时候我们就可以直接使用Ioc容器了。]]></content>
      <categories>
        <category>Spring源码分析-IOC（一）容器</category>
      </categories>
      <tags>
        <tag>Spring源码分析-IOC（一）容器</tag>
      </tags>
  </entry>
</search>
