---
title: JVM系列（三）GC算法 GC收集器
comments: true
tags:
  - JVM系列（三）GC算法 GC收集器
categories:
  - JVM系列（三）GC算法 GC收集器
url: 239.html
id: 239
date: 2017-05-26 16:23:00
---

jvm中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收**主要集中于 java 堆和方****法区中**，在程序运行期间，这部分内存的分配和使用都是动态的，垃圾回收器关注的也是这部分内存。

对象死了吗？
------

上文中说到了对象GC过程，其中对象符合了GC条件就会被垃圾回收器（GC回收器）所回收。那么怎么才算符合GC条件呢？在Java中一个对象只要被指针指向（也就是还有对象引用）那么这个对象就是个‘活对象’，反之，即为‘死对象’。那么怎么确定对象是否还被指针指向呢？这里有两种算法来确定对象是否被指针指向：

*   引用计数法：给对象添加一个引用计数器，每当有地方引用该对象时，计数器+1。但引用失效时，计数器-1。
*   可达性分析算法：通过“GC ROOT”对象作为起始点，从这些起始点向下搜索，搜索的路径成为引用链。当一个对象没有与任何引用链相连时，那么这个对象就为“死对象”。Java判断对象是否存活，使用的就是可达性分析算法。

那么那些对象可以称为GC ROOT对象呢

*   虚拟机栈中引用的对象。
*   方法区中类静态属性实体引用的对象。
*   方法区中常量引用的对象。
*   本地方法栈中JNI引用的对象。

![引用](http://www.zzcode.cn/wp-content/uploads/2017/05/引用-3.png)![20160514180110374](http://www.zzcode.cn/wp-content/uploads/2017/05/20160514180110374-1.png)

垃圾回收算法
------

根据对象存活周期不同把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“**标记-清理**”或“**标记-整理**”算法来进行回收。这种垃圾回收方式就是**分代收集。**那么接下来详细说说各种垃圾回收算法。

**标记-清理**

“**标记-清除**”（Mark-Sweep）算法，如它的名字一样，标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。它是最基础的收集算法，后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。

它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，**空间碎片太多**可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![1](http://www.zzcode.cn/wp-content/uploads/2017/05/1-1.png)

**标记-压缩算法**

标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，**清理边界外所有的空间。**

![1](http://www.zzcode.cn/wp-content/uploads/2017/05/1-2.png)

**复制算法**

与标记-清除算法相比，复制算法是一种相对高效的回收方法，不适用于存活对象较多的场合 如老年代。将原有的内存空间分为两块（**From Survivor空间**、**To Survivor空间**），每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

![1](http://www.zzcode.cn/wp-content/uploads/2017/05/1-3.png)

Stop The Word
-------------

stop the word是指在GC过程中，停止掉所有用户线程，只有一条线程去执行垃圾收集工作。它在进行垃圾收集工作时，必须站停掉所有的工作线程，直到他收集结束。stop the word是Java中一种全局暂停的现象。很容易理解为什么在GC过程中需要“stop the word”，–类比在聚会时打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。同时stop the word也会带来一定的危害：譬如 长时间服务停止，没有响应或者是–遇到HA系统，可能引起主备切换，严重危害生产环境。

**垃圾回收器**
---------

**Serial收集器**

串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用**一个线程**去回收。新生代、老年代使用**串行**回收；**新生代复制算法**、**老年代标记-压缩**；垃圾收集的过程中会Stop The World（服务暂停）

参数控制：**-XX:+UseSerialGC**串行收集器

![wxid_7oo45hzg7yhl22_1495857615532_77](http://www.zzcode.cn/wp-content/uploads/2017/05/wxid_7oo45hzg7yhl22_1495857615532_77.png)

**ParNew收集器**

ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩

参数控制：     **-XX:+UseParNewGC**ParNew收集器

**-XX:ParallelGCThreads **限制线程数量

![wxid_7oo45hzg7yhl22_1495857615532_77](http://www.zzcode.cn/wp-content/uploads/2017/05/wxid_7oo45hzg7yhl22_1495857615532_77-1.png)

**Parallel收集器**

Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的**吞吐量**。可以通过参数来打开**自适应调节策略，**虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩

参数控制：**-XX:+UseParallelGC  **使用Parallel收集器+ 老年代串行

**Paralle****l**** Old** **收集器**

Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供

参数控制：** -XX:+UseParallelOldGC **使用Parallel收集器+ 老年代并行

**CMS收集器**

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： 

初始标记（CMS initial mark）

并发标记（CMS concurrent mark）

重新标记（CMS remark）

并发清除（CMS concurrent sweep）

 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。   
      由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。**老年代收集器**（新生代使用ParNew）

  优点:**并发收集**、**低停顿** 

缺点：**产生大量空间碎片****、****并发阶段会降低吞吐量**

   参数控制：**-XX:+UseConcMarkSweepGC  **使用CMS收集器

**-XX:+ UseCMSCompactAtFullCollection **Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长

**-XX:+CMSFullGCsBeforeCompaction  **设置进行几次Full GC后，进行一次碎片整理

            -**XX:ParallelCMSThreads ** 设定CMS的线程数量（一般情况约等于可用CPU数量）

![wxid_7oo45hzg7yhl22_1495857615532_77](http://www.zzcode.cn/wp-content/uploads/2017/05/wxid_7oo45hzg7yhl22_1495857615532_77-2.png)

**G1****收集器**

G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：

1. **空间整合**，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。

2. **可预测停顿**，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。

[![wps3B4C.tmp](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174247641-1572774731.jpg "wps3B4C.tmp")](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174247125-2073079982.jpg)

G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。

**收集步骤**：

1、**标记阶段**，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)

2、**Root Region Scanning**，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。

3、**Concurrent Marking**，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。

[![wps93E7.tmp](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174249203-774809988.png "wps93E7.tmp")](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174248703-2128319077.png)

4、**Remark**, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。

5、**Copy/Clean up**，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。

[![wps47EC.tmp](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174250656-1729618538.png "wps47EC.tmp")](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174249938-1165331497.png)

6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。

[![wpsEAB1.tmp](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174252078-703896755.png "wpsEAB1.tmp")](http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174251406-2060589648.png)

**收集器组合**
---------

![650075-8c5080659578032d](http://www.zzcode.cn/wp-content/uploads/2017/05/650075-8c5080659578032d.jpg)

单核单线程：Serial + Serial Old

多核多线程：ParNew + CMS

吞吐量：Parallel Scavenge + Parallel old

停顿时间：ParNew + CMS 或者是 G1 +G1